
/* parser generated by jison 0.6.0-186 */

/*
 * Returns a Parser object of the following structure:
 *
 *  Parser: {
 *    yy: {}     The so-called "shared state" or rather the *source* of it;
 *               the real "shared state" `yy` passed around to
 *               the rule actions, etc. is a derivative/copy of this one,
 *               not a direct reference!
 *  }
 *
 *  Parser.prototype: {
 *    yy: {},
 *    EOF: 1,
 *    TERROR: 2,
 *
 *    trace: function(errorMessage, ...),
 *
 *    JisonParserError: function(msg, hash),
 *
 *    quoteName: function(name),
 *               Helper function which can be overridden by user code later on: put suitable
 *               quotes around literal IDs in a description string.
 *
 *    originalQuoteName: function(name),
 *               The basic quoteName handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function
 *               at the end of the `parse()`.
 *
 *    describeSymbol: function(symbol),
 *               Return a more-or-less human-readable description of the given symbol, when
 *               available, or the symbol itself, serving as its own 'description' for lack
 *               of something better to serve up.
 *
 *               Return NULL when the symbol is unknown to the parser.
 *
 *    symbols_: {associative list: name ==> number},
 *    terminals_: {associative list: number ==> name},
 *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},
 *    terminal_descriptions_: (if there are any) {associative list: number ==> description},
 *    productions_: [...],
 *
 *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),
 *
 *               The function parameters and `this` have the following value/meaning:
 *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)
 *                             to store/reference the rule value `$$` and location info `@$`.
 *
 *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets
 *                 to see the same object via the `this` reference, i.e. if you wish to carry custom
 *                 data from one reduce action through to the next within a single parse run, then you
 *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.
 *
 *                 `this.yy` is a direct reference to the `yy` shared state object.
 *
 *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`
 *                 object at `parse()` start and are therefore available to the action code via the
 *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from
 *                 the %parse-param` list.
 *
 *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used
 *                             to match this rule. This is *not* the look-ahead token, but the last token
 *                             that's actually part of this rule.
 *
 *                 Formulated another way, `yytext` is the value of the token immediately preceeding
 *                 the current look-ahead token.
 *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.
 *
 *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.
 *
 *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.
 *
 *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.
 *
 *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead
 *                               of an empty object when no suitable location info can be provided.
 *
 *               - `yystate` : the current parser state number, used internally for dispatching and
 *                               executing the action code chunk matching the rule currently being reduced.
 *
 *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *                 Also note that you can access this and other stack index values using the new double-hash
 *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things
 *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.
 *                 This is made available to write very advanced grammar action rules, e.g. when you want
 *                 to investigate the parse state stack in your action code, which would, for example,
 *                 be relevant when you wish to implement error diagnostics and reporting schemes similar
 *                 to the work described here:
 *
 *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.
 *                   In Journées Francophones des Languages Applicatifs.
 *
 *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.
 *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631–640.
 *
 *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.
 *                             constructs.
 *
 *               - `yylstack`: reference to the parser token location stack. Also accessed via
 *                             the `@1` etc. constructs.
 *
 *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are
 *                             UNDEFINED rather than an empty (location) object, when the lexer/parser
 *                             action code did not provide a suitable location info object when such a
 *                             slot was filled!
 *
 *               - `yystack` : reference to the parser token id stack. Also accessed via the
 *                             `#1` etc. constructs.
 *
 *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to
 *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might
 *                 want access this array for your own purposes, such as error analysis as mentioned above!
 *
 *                 Note that this stack stores the current stack of *tokens*, that is the sequence of
 *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*
 *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and
 *                 *reduced*.
 *
 *               - `yysstack`: reference to the parser state stack. This one carries the internal parser
 *                             *states* such as the one in `yystate`, which are used to represent
 *                             the parser state machine in the *parse table*. *Very* *internal* stuff,
 *                             what can I say? If you access this one, you're clearly doing wicked things
 *
 *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your
 *                             grammar definition file.
 *
 *    table: [...],
 *               State transition table
 *               ----------------------
 *
 *               index levels are:
 *               - `state`  --> hash table
 *               - `symbol` --> action (number or array)
 *
 *                 If the `action` is an array, these are the elements' meaning:
 *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept
 *                 - index [1]: GOTO `state`
 *
 *                 If the `action` is a number, it is the GOTO `state`
 *
 *    defaultActions: {...},
 *
 *    parseError: function(str, hash, ExceptionClass),
 *    yyError: function(str, ...),
 *    yyRecovering: function(),
 *    yyErrOk: function(),
 *    yyClearIn: function(),
 *
 *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
 *               See it's use in this parser kernel in many places; example usage:
 *
 *                   var infoObj = parser.constructParseErrorInfo('fail!', null,
 *                                     parser.collect_expected_token_set(state), true);
 *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);
 *
 *    originalParseError: function(str, hash, ExceptionClass),
 *               The basic `parseError` handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function
 *               at the end of the `parse()`.
 *
 *    options: { ... parser %options ... },
 *
 *    parse: function(input[, args...]),
 *               Parse the given `input` and return the parsed value (or `true` when none was provided by
 *               the root action, in which case the parser is acting as a *matcher*).
 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:
 *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
 *
 *               WARNING:
 *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with
 *               any attributes already added to `yy` by the jison run-time; 
 *               when such a collision is detected an exception is thrown to prevent the generated run-time 
 *               from silently accepting this confusing and potentially hazardous situation!
 *
 *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in 
 *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state
 *               object and any collision with those will be reported by the lexer via a thrown exception.
 *
 *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown
 *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY
 *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and
 *               the internal parser gets properly garbage collected under these particular circumstances.
 *
 *    mergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API can be invoked to calculate a spanning `yylloc` location info object.
 *
 *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case
 *               this function will attempt to obtain a suitable location marker by inspecting the location stack
 *               backwards.
 *
 *               For more info see the documentation comment further below, immediately above this function's
 *               implementation.
 *
 *    lexer: {
 *        yy: {...},           A reference to the so-called "shared state" `yy` once
 *                             received via a call to the `.setInput(input, yy)` lexer API.
 *        EOF: 1,
 *        ERROR: 2,
 *        JisonLexerError: function(msg, hash),
 *        parseError: function(str, hash, ExceptionClass),
 *        setInput: function(input, [yy]),
 *        input: function(),
 *        unput: function(str),
 *        more: function(),
 *        reject: function(),
 *        less: function(n),
 *        pastInput: function(n),
 *        upcomingInput: function(n),
 *        showPosition: function(),
 *        test_match: function(regex_match_array, rule_index, ...),
 *        next: function(...),
 *        lex: function(...),
 *        begin: function(condition),
 *        pushState: function(condition),
 *        popState: function(),
 *        topState: function(),
 *        _currentRules: function(),
 *        stateStackSize: function(),
 *        cleanupAfterLex: function()
 *
 *        options: { ... lexer %options ... },
 *
 *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),
 *        rules: [...],
 *        conditions: {associative list: name ==> set},
 *    }
 *  }
 *
 *
 *  token location info (@$, _$, etc.): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The `parseError` function receives a 'hash' object with these members for lexer and
 * parser errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *  }
 *
 * parser (grammar) errors will also provide these additional members:
 *
 *  {
 *    expected:    (array describing the set of expected tokens;
 *                  may be UNDEFINED when we cannot easily produce such a set)
 *    state:       (integer (or array when the table includes grammar collisions);
 *                  represents the current internal state of the parser kernel.
 *                  can, for example, be used to pass to the `collect_expected_token_set()`
 *                  API to obtain the expected token set)
 *    action:      (integer; represents the current internal action which will be executed)
 *    new_state:   (integer; represents the next/planned internal state, once the current
 *                  action has executed)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    yy:          (object: the current parser internal "shared state" `yy`
 *                  as is also available in the rule actions; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *    parser:      (reference to the current parser instance)
 *  }
 *
 * while `this` will reference the current parser instance.
 *
 * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    lexer:       (reference to the current lexer instance which reported the error)
 *  }
 *
 * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired
 * from either the parser or lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    exception:   (reference to the exception thrown)
 *  }
 *
 * Please do note that in the latter situation, the `expected` field will be omitted as
 * this type of failure is assumed not to be due to *parse errors* but rather due to user
 * action code in either parser or lexer failing unexpectedly.
 *
 * ---
 *
 * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.
 * These options are available:
 *
 * ### options which are global for all parser instances
 *
 *  Parser.pre_parse: function(yy)
 *                 optional: you can specify a pre_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`.
 *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: you can specify a post_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`. When it does not return any value,
 *                 the parser will return the original `retval`.
 *
 * ### options which can be set up per parser instance
 *
 *  yy: {
 *      pre_parse:  function(yy)
 *                 optional: is invoked before the parse cycle starts (and before the first
 *                 invocation of `lex()`) but immediately after the invocation of
 *                 `parser.pre_parse()`).
 *      post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: is invoked when the parse terminates due to success ('accept')
 *                 or failure (even when exceptions are thrown).
 *                 `retval` contains the return value to be produced by `Parser.parse()`;
 *                 this function can override the return value by returning another.
 *                 When it does not return any value, the parser will return the original
 *                 `retval`.
 *                 This function is invoked immediately before `parser.post_parse()`.
 *
 *      parseError: function(str, hash, ExceptionClass)
 *                 optional: overrides the default `parseError` function.
 *      quoteName: function(name),
 *                 optional: overrides the default `quoteName` function.
 *  }
 *
 *  parser.lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */
var lexParser = (function () {

// See also:
// http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
// but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
// with userland code which might access the derived class in a 'classic' way.
function JisonParserError(msg, hash) {
    Object.defineProperty(this, 'name', {
        enumerable: false,
        writable: false,
        value: 'JisonParserError'
    });

    if (msg == null) msg = '???';

    Object.defineProperty(this, 'message', {
        enumerable: false,
        writable: true,
        value: msg
    });

    this.hash = hash;

    var stacktrace;
    if (hash && hash.exception instanceof Error) {
        var ex2 = hash.exception;
        this.message = ex2.message || msg;
        stacktrace = ex2.stack;
    }
    if (!stacktrace) {
        if (Error.hasOwnProperty('captureStackTrace')) { // V8
            Error.captureStackTrace(this, this.constructor);
        } else {
            stacktrace = (new Error(msg)).stack;
        }
    }
    if (stacktrace) {
        Object.defineProperty(this, 'stack', {
            enumerable: false,
            writable: false,
            value: stacktrace
        });
    }
}

if (typeof Object.setPrototypeOf === 'function') {
    Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);
} else {
    JisonParserError.prototype = Object.create(Error.prototype);
}
JisonParserError.prototype.constructor = JisonParserError;
JisonParserError.prototype.name = 'JisonParserError';




// helper: reconstruct the productions[] table
function bp(s) {
    var rv = [];
    var p = s.pop;
    var r = s.rule;
    for (var i = 0, l = p.length; i < l; i++) {
        rv.push([
            p[i],
            r[i]
        ]);
    }
    return rv;
}



// helper: reconstruct the defaultActions[] table
function bda(s) {
    var rv = {};
    var d = s.idx;
    var g = s.goto;
    for (var i = 0, l = d.length; i < l; i++) {
        var j = d[i];
        rv[j] = g[i];
    }
    return rv;
}



// helper: reconstruct the 'goto' table
function bt(s) {
    var rv = [];
    var d = s.len;
    var y = s.symbol;
    var t = s.type;
    var a = s.state;
    var m = s.mode;
    var g = s.goto;
    for (var i = 0, l = d.length; i < l; i++) {
        var n = d[i];
        var q = {};
        for (var j = 0; j < n; j++) {
            var z = y.shift();
            switch (t.shift()) {
            case 2:
                q[z] = [
                    m.shift(),
                    g.shift()
                ];
                break;

            case 0:
                q[z] = a.shift();
                break;

            default:
                // type === 1: accept
                q[z] = [
                    3
                ];
            }
        }
        rv.push(q);
    }
    return rv;
}



// helper: runlength encoding with increment step: code, length: step (default step = 0)
// `this` references an array
function s(c, l, a) {
    a = a || 0;
    for (var i = 0; i < l; i++) {
        this.push(c);
        c += a;
    }
}

// helper: duplicate sequence from *relative* offset and length.
// `this` references an array
function c(i, l) {
    i = this.length - i;
    for (l += i; i < l; i++) {
        this.push(this[i]);
    }
}

// helper: unpack an array using helpers and data, all passed in an array argument 'a'.
function u(a) {
    var rv = [];
    for (var i = 0, l = a.length; i < l; i++) {
        var e = a[i];
        // Is this entry a helper function?
        if (typeof e === 'function') {
            i++;
            e.apply(rv, a[i]);
        } else {
            rv.push(e);
        }
    }
    return rv;
}


var parser = {
    // Code Generator Information Report
    // ---------------------------------
    //
    // Options:
    //
    //   no default action: ............... false
    //   no try..catch: ................... false
    //   no default resolve on conflict:    false
    //   on-demand look-ahead: ............ false
    //   error recovery token skip maximum: 3
    //   yyerror in parse actions is: ..... NOT recoverable,
    //   yyerror in lexer actions and other non-fatal lexer are:
    //   .................................. NOT recoverable,
    //   debug grammar/output: ............ false
    //   has partial LR conflict upgrade:   true
    //   rudimentary token-stack support:   false
    //   parser table compression mode: ... 2
    //   export debug tables: ............. false
    //   export *all* tables: ............. false
    //   module type: ..................... commonjs
    //   parser engine type: .............. lalr
    //   output main() in the module: ..... true
    //   number of expected conflicts: .... 0
    //
    //
    // Parser Analysis flags:
    //
    //   all actions are default: ......... false
    //   uses yyleng: ..................... false
    //   uses yylineno: ................... false
    //   uses yytext: ..................... false
    //   uses yylloc: ..................... false
    //   uses ParseError API: ............. false
    //   uses YYERROR: .................... true
    //   uses YYRECOVERING: ............... false
    //   uses YYERROK: .................... false
    //   uses YYCLEARIN: .................. false
    //   tracks rule values: .............. true
    //   assigns rule values: ............. true
    //   uses location tracking: .......... true
    //   assigns location: ................ true
    //   uses yystack: .................... false
    //   uses yysstack: ................... false
    //   uses yysp: ....................... true
    //   uses yyrulelength: ............... false
    //   has error recovery: .............. true
    //
    // --------- END OF REPORT -----------

trace: function no_op_trace() { },
JisonParserError: JisonParserError,
yy: {},
options: {
  type: "lalr",
  hasPartialLrUpgradeOnConflict: true,
  errorRecoveryTokenDiscardCount: 3
},
symbols_: {
  "$": 17,
  "$accept": 0,
  "$end": 1,
  "%%": 19,
  "(": 10,
  ")": 11,
  "*": 7,
  "+": 12,
  ",": 8,
  ".": 15,
  "/": 14,
  "/!": 28,
  "<": 5,
  "=": 18,
  ">": 6,
  "?": 13,
  "ACTION": 23,
  "ACTION_BODY": 26,
  "CHARACTER_LIT": 36,
  "CODE": 43,
  "EOF": 1,
  "ESCAPE_CHAR": 33,
  "INCLUDE": 41,
  "NAME": 20,
  "NAME_BRACE": 29,
  "OPTIONS": 37,
  "OPTIONS_END": 38,
  "OPTION_STRING_VALUE": 39,
  "OPTION_VALUE": 40,
  "PATH": 42,
  "RANGE_REGEX": 34,
  "REGEX_SET": 32,
  "REGEX_SET_END": 31,
  "REGEX_SET_START": 30,
  "SPECIAL_GROUP": 27,
  "START_COND": 25,
  "START_EXC": 22,
  "START_INC": 21,
  "STRING_LIT": 35,
  "UNKNOWN_DECL": 24,
  "^": 16,
  "action": 55,
  "action_body": 57,
  "action_comments_body": 58,
  "any_group_regex": 67,
  "definition": 48,
  "definitions": 47,
  "error": 2,
  "escape_char": 70,
  "extra_lexer_module_code": 76,
  "include_macro_code": 77,
  "init": 46,
  "lex": 44,
  "module_code_chunk": 78,
  "name_expansion": 66,
  "name_list": 60,
  "names_exclusive": 50,
  "names_inclusive": 49,
  "nonempty_regex_list": 63,
  "option": 75,
  "option_list": 74,
  "optional_module_code_chunk": 79,
  "options": 73,
  "range_regex": 71,
  "regex": 61,
  "regex_base": 65,
  "regex_concat": 64,
  "regex_list": 62,
  "regex_set": 68,
  "regex_set_atom": 69,
  "rule": 54,
  "rule_block": 53,
  "rules": 51,
  "rules_and_epilogue": 45,
  "rules_collective": 52,
  "start_conditions": 59,
  "string": 72,
  "unbracketed_action_body": 56,
  "{": 3,
  "|": 9,
  "}": 4
},
terminals_: {
  1: "EOF",
  2: "error",
  3: "{",
  4: "}",
  5: "<",
  6: ">",
  7: "*",
  8: ",",
  9: "|",
  10: "(",
  11: ")",
  12: "+",
  13: "?",
  14: "/",
  15: ".",
  16: "^",
  17: "$",
  18: "=",
  19: "%%",
  20: "NAME",
  21: "START_INC",
  22: "START_EXC",
  23: "ACTION",
  24: "UNKNOWN_DECL",
  25: "START_COND",
  26: "ACTION_BODY",
  27: "SPECIAL_GROUP",
  28: "/!",
  29: "NAME_BRACE",
  30: "REGEX_SET_START",
  31: "REGEX_SET_END",
  32: "REGEX_SET",
  33: "ESCAPE_CHAR",
  34: "RANGE_REGEX",
  35: "STRING_LIT",
  36: "CHARACTER_LIT",
  37: "OPTIONS",
  38: "OPTIONS_END",
  39: "OPTION_STRING_VALUE",
  40: "OPTION_VALUE",
  41: "INCLUDE",
  42: "PATH",
  43: "CODE"
},
TERROR: 2,
EOF: 1,

// internals: defined here so the object *structure* doesn't get modified by parse() et al,
// thus helping JIT compilers like Chrome V8.
originalQuoteName: null,
originalParseError: null,
cleanupAfterParse: null,
constructParseErrorInfo: null,
mergeLocationInfo: null,

__reentrant_call_depth: 0,      // INTERNAL USE ONLY
__error_infos: [],              // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup

// APIs which will be set up depending on user action code analysis:
//yyRecovering: 0,
//yyErrOk: 0,
//yyClearIn: 0,

// Helper APIs
// -----------

// Helper function which can be overridden by user code later on: put suitable quotes around
// literal IDs in a description string.
quoteName: function parser_quoteName(id_str) {
    return '"' + id_str + '"';
},

// Return a more-or-less human-readable description of the given symbol, when available,
// or the symbol itself, serving as its own 'description' for lack of something better to serve up.
//
// Return NULL when the symbol is unknown to the parser.
describeSymbol: function parser_describeSymbol(symbol) {
    if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {
        return this.terminal_descriptions_[symbol];
    }
    else if (symbol === this.EOF) {
        return 'end of input';
    }
    else if (this.terminals_[symbol]) {
        return this.quoteName(this.terminals_[symbol]);
    }
    // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.
    //
    // An example of this may be where a rule's action code contains a call like this:
    //
    //      parser.describeSymbol(#$)
    //
    // to obtain a human-readable description or name of the current grammar rule. This comes handy in
    // error handling action code blocks, for example.
    var s = this.symbols_;
    for (var key in s) {
        if (s[key] === symbol) {
            return key;
        }
    }
    return null;
},

// Produce a (more or less) human-readable list of expected tokens at the point of failure.
//
// The produced list may contain token or token set descriptions instead of the tokens
// themselves to help turning this output into something that easier to read by humans
// unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,
// expected terminals and nonterminals is produced.
//
// The returned list (array) will not contain any duplicate entries.
collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {
    var TERROR = this.TERROR;
    var tokenset = [];
    var check = {};
    // Has this (error?) state been outfitted with a custom expectations description text for human consumption?
    // If so, use that one instead of the less palatable token set.
    if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {
        return [
            this.state_descriptions_[state]
        ];
    }
    for (var p in this.table[state]) {
        p = +p;
        if (p !== TERROR) {
            var d = do_not_describe ? p : this.describeSymbol(p);
            if (d && !check[d]) {
                tokenset.push(d);
                check[d] = true;        // Mark this token description as already mentioned to prevent outputting duplicate entries.
            }
        }
    }
    return tokenset;
},
productions_: bp({
  pop: u([
  44,
  44,
  s,
  [45, 3],
  46,
  47,
  47,
  s,
  [48, 9],
  49,
  49,
  50,
  50,
  51,
  51,
  s,
  [52, 4],
  53,
  53,
  54,
  54,
  s,
  [55, 4],
  56,
  56,
  s,
  [57, 3],
  58,
  58,
  s,
  [59, 4],
  60,
  60,
  61,
  62,
  62,
  s,
  [63, 3],
  64,
  64,
  s,
  [65, 17],
  66,
  67,
  67,
  68,
  68,
  69,
  s,
  [69, 4, 1],
  72,
  73,
  74,
  74,
  s,
  [75, 4],
  76,
  76,
  77,
  77,
  78,
  78,
  79,
  79
]),
  rule: u([
  s,
  [4, 3],
  2,
  0,
  0,
  2,
  0,
  s,
  [2, 3],
  3,
  3,
  s,
  [1, 5],
  2,
  1,
  2,
  c,
  [15, 3],
  4,
  4,
  3,
  c,
  [21, 4],
  c,
  [20, 5],
  2,
  1,
  5,
  4,
  0,
  c,
  [11, 3],
  3,
  0,
  1,
  c,
  [15, 3],
  0,
  3,
  c,
  [34, 3],
  1,
  s,
  [3, 4],
  s,
  [2, 5],
  c,
  [12, 3],
  s,
  [1, 6],
  c,
  [16, 3],
  c,
  [10, 8],
  c,
  [9, 3],
  s,
  [3, 3],
  c,
  [8, 3],
  c,
  [30, 4],
  0
])
}),
performAction: function parser__PerformAction(yyloc, yystate /* action[1] */, yysp, yyrulelength, yyvstack, yylstack) {

          /* this == yyval */

          // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!
          var yy = this.yy;
          var yyparser = yy.parser;
          var yylexer = yy.lexer;

          

          switch (yystate) {
case 0:
    /*! Production::    $accept : lex $end */
    // default action (generated by JISON):
    this.$ = yyvstack[yysp - 1];
    this._$ = yylstack[yysp - 1];
    break;

case 1:
    /*! Production::    lex : init definitions rules_and_epilogue EOF */
    this.$ = yyvstack[yysp - 1];
    this.$.macros = yyvstack[yysp - 2].macros;
    this.$.startConditions = yyvstack[yysp - 2].startConditions;
    this.$.unknownDecls = yyvstack[yysp - 2].unknownDecls;
    // if there are any options, add them all, otherwise set options to NULL:
    // can't check for 'empty object' by `if (yy.options) ...` so we do it this way:
    for (var k in yy.options) {
      this.$.options = yy.options;
      break;
    }
    if (yy.actionInclude) {
      var asrc = yy.actionInclude.join('\n\n');
      // Only a non-empty action code chunk should actually make it through:
      if (asrc.trim() !== '') {
        this.$.actionInclude = asrc;
      }
    }
    delete yy.options;
    delete yy.actionInclude;
    return this.$;
    break;

case 2:
    /*! Production::    lex : init definitions error EOF */
    yyparser.yyError("Maybe you did not correctly separate the lexer sections with a '%%' on an otherwise empty line? The lexer spec file should have this structure:  definitions  %%  rules  [%%  extra_module_code]", yylstack[yysp - 1]);
    break;

case 3:
    /*! Production::    rules_and_epilogue : "%%" rules "%%" extra_lexer_module_code */
    if (yyvstack[yysp] && yyvstack[yysp].trim() !== '') {
      this.$ = { rules: yyvstack[yysp - 2], moduleInclude: yyvstack[yysp] };
    } else {
      this.$ = { rules: yyvstack[yysp - 2] };
    }
    break;

case 4:
    /*! Production::    rules_and_epilogue : "%%" rules */
    this.$ = { rules: yyvstack[yysp] };
    break;

case 5:
    /*! Production::    rules_and_epilogue : ε */
    this.$ = { rules: [] };
    break;

case 6:
    /*! Production::    init : ε */
    yy.actionInclude = [];
    if (!yy.options) yy.options = {};
    break;

case 7:
    /*! Production::    definitions : definition definitions */
    this.$ = yyvstack[yysp];
    if (yyvstack[yysp - 1] != null) {
      if ('length' in yyvstack[yysp - 1]) {
        this.$.macros[yyvstack[yysp - 1][0]] = yyvstack[yysp - 1][1];
      } else if (yyvstack[yysp - 1].type === 'names') {
        for (var name in yyvstack[yysp - 1].names) {
          this.$.startConditions[name] = yyvstack[yysp - 1].names[name];
        }
      } else if (yyvstack[yysp - 1].type === 'unknown') {
        this.$.unknownDecls.push(yyvstack[yysp - 1].body);
      }
    }
    break;

case 8:
    /*! Production::    definitions : ε */
    this.$ = {
      macros: {},           // { hash table }
      startConditions: {},  // { hash table }
      unknownDecls: []      // [ array of [key,value] pairs }
    };
    break;

case 9:
    /*! Production::    definition : NAME regex */
case 30:
    /*! Production::    rule : regex action */
case 31:
    /*! Production::    rule : regex error */
    this.$ = [yyvstack[yysp - 1], yyvstack[yysp]];
    break;

case 10:
    /*! Production::    definition : START_INC names_inclusive */
case 11:
    /*! Production::    definition : START_EXC names_exclusive */
case 34:
    /*! Production::    action : unbracketed_action_body */
case 35:
    /*! Production::    action : include_macro_code */
case 38:
    /*! Production::    action_body : action_comments_body */
case 81:
    /*! Production::    escape_char : ESCAPE_CHAR */
case 82:
    /*! Production::    range_regex : RANGE_REGEX */
case 92:
    /*! Production::    extra_lexer_module_code : optional_module_code_chunk */
case 96:
    /*! Production::    module_code_chunk : CODE */
case 98:
    /*! Production::    optional_module_code_chunk : module_code_chunk */
    this.$ = yyvstack[yysp];
    break;

case 12:
    /*! Production::    definition : "{" action_body "}" */
    yy.actionInclude.push(yyvstack[yysp - 1]); this.$ = null;
    break;

case 13:
    /*! Production::    definition : "{" action_body error */
    var l = yyvstack[yysp - 1].split('\n');
    var ab = l.slice(0, 10).join('\n');
    yyparser.yyError("Seems you did not correctly bracket the lexer 'preparatory' action block in curly braces: '{ ... }'. Offending action body:\n" + ab);
    break;

case 14:
    /*! Production::    definition : ACTION */
case 15:
    /*! Production::    definition : include_macro_code */
    yy.actionInclude.push(yyvstack[yysp]); this.$ = null;
    break;

case 16:
    /*! Production::    definition : options */
    this.$ = null;
    break;

case 17:
    /*! Production::    definition : UNKNOWN_DECL */
    this.$ = {type: 'unknown', body: yyvstack[yysp]};
    break;

case 18:
    /*! Production::    names_inclusive : START_COND */
    this.$ = {type: 'names', names: {}}; this.$.names[yyvstack[yysp]] = 0;
    break;

case 19:
    /*! Production::    names_inclusive : names_inclusive START_COND */
    this.$ = yyvstack[yysp - 1]; this.$.names[yyvstack[yysp]] = 0;
    break;

case 20:
    /*! Production::    names_exclusive : START_COND */
    this.$ = {type: 'names', names: {}}; this.$.names[yyvstack[yysp]] = 1;
    break;

case 21:
    /*! Production::    names_exclusive : names_exclusive START_COND */
    this.$ = yyvstack[yysp - 1]; this.$.names[yyvstack[yysp]] = 1;
    break;

case 22:
    /*! Production::    rules : rules rules_collective */
    this.$ = yyvstack[yysp - 1].concat(yyvstack[yysp]);
    break;

case 23:
    /*! Production::    rules : ε */
case 29:
    /*! Production::    rule_block : ε */
    this.$ = [];
    break;

case 24:
    /*! Production::    rules_collective : start_conditions rule */
    if (yyvstack[yysp - 1]) {
        yyvstack[yysp].unshift(yyvstack[yysp - 1]);
    }
    this.$ = [yyvstack[yysp]];
    break;

case 25:
    /*! Production::    rules_collective : start_conditions "{" rule_block "}" */
    if (yyvstack[yysp - 3]) {
        yyvstack[yysp - 1].forEach(function (d) {
            d.unshift(yyvstack[yysp - 3]);
        });
    }
    this.$ = yyvstack[yysp - 1];
    break;

case 26:
    /*! Production::    rules_collective : start_conditions "{" error "}" */
    yyparser.yyError("Seems you made a mistake while specifying one of the lexer rules inside the start condition <" + yyvstack[yysp - 3].join(',') + "> { rules... } block.", yylstack[yysp - 1]);
    break;

case 27:
    /*! Production::    rules_collective : start_conditions "{" error */
    yyparser.yyError("Seems you did not correctly bracket a lexer rules set inside the start condition <" + yyvstack[yysp - 2].join(',') + "> { rules... } as a terminating curly brace '}' could not be found.", yylstack[yysp], $rule_block);
    break;

case 28:
    /*! Production::    rule_block : rule_block rule */
    this.$ = yyvstack[yysp - 1]; this.$.push(yyvstack[yysp]);
    break;

case 32:
    /*! Production::    action : "{" action_body "}" */
case 43:
    /*! Production::    start_conditions : "<" name_list ">" */
    this.$ = yyvstack[yysp - 1];
    break;

case 33:
    /*! Production::    action : "{" action_body error */
    var l = yyvstack[yysp - 1].split('\n');
    var ab = l.slice(0, 10).join('\n');
    yyparser.yyError("Seems you did not correctly bracket a lexer rule action block in curly braces: '{ ... }'. Offending action body:\n" + ab);
    break;

case 36:
    /*! Production::    unbracketed_action_body : ACTION */
case 50:
    /*! Production::    regex_list : nonempty_regex_list */
case 54:
    /*! Production::    nonempty_regex_list : regex_concat */
case 56:
    /*! Production::    regex_concat : regex_base */
case 66:
    /*! Production::    regex_base : name_expansion */
case 68:
    /*! Production::    regex_base : any_group_regex */
case 72:
    /*! Production::    regex_base : string */
case 73:
    /*! Production::    regex_base : escape_char */
case 74:
    /*! Production::    name_expansion : NAME_BRACE */
case 78:
    /*! Production::    regex_set : regex_set_atom */
case 79:
    /*! Production::    regex_set_atom : REGEX_SET */
case 84:
    /*! Production::    string : CHARACTER_LIT */
case 87:
    /*! Production::    option_list : option */
    // default action (generated by JISON):
    this.$ = yyvstack[yysp];
    this._$ = yylstack[yysp];
    break;

case 37:
    /*! Production::    unbracketed_action_body : unbracketed_action_body ACTION */
    this.$ = yyvstack[yysp - 1] + '\n' + yyvstack[yysp];
    break;

case 39:
    /*! Production::    action_body : action_body "{" action_body "}" action_comments_body */
    this.$ = yyvstack[yysp - 4] + yyvstack[yysp - 3] + yyvstack[yysp - 2] + yyvstack[yysp - 1] + yyvstack[yysp];
    break;

case 40:
    /*! Production::    action_body : action_body "{" action_body error */
    var l = yyvstack[yysp - 1].split('\n');
    var ab = l.slice(0, 10).join('\n');
    yyparser.yyError("Seems you did not correctly match curly braces '{ ... }' in a lexer rule action block. Offending action body part:\n" + ab);
    break;

case 41:
    /*! Production::    action_comments_body : ε */
case 51:
    /*! Production::    regex_list : ε */
case 99:
    /*! Production::    optional_module_code_chunk : ε */
    this.$ = '';
    break;

case 42:
    /*! Production::    action_comments_body : action_comments_body ACTION_BODY */
case 55:
    /*! Production::    regex_concat : regex_concat regex_base */
case 67:
    /*! Production::    regex_base : regex_base range_regex */
case 77:
    /*! Production::    regex_set : regex_set_atom regex_set */
case 97:
    /*! Production::    module_code_chunk : module_code_chunk CODE */
    this.$ = yyvstack[yysp - 1] + yyvstack[yysp];
    break;

case 44:
    /*! Production::    start_conditions : "<" name_list error */
    var l = yyvstack[yysp - 1];
    var ab = l.slice(0, 10).join(',').replace(/[\s\r\n]/g, ' ');
    yyparser.yyError("Seems you did not correctly terminate the start condition set <" + ab + ",???> with a terminating '>'");
    break;

case 45:
    /*! Production::    start_conditions : "<" "*" ">" */
    this.$ = ['*'];
    break;

case 46:
    /*! Production::    start_conditions : ε */
    // default action (generated by JISON):
    this.$ = undefined;
    this._$ = undefined;
    break;

case 47:
    /*! Production::    name_list : NAME */
    this.$ = [yyvstack[yysp]];
    break;

case 48:
    /*! Production::    name_list : name_list "," NAME */
    this.$ = yyvstack[yysp - 2]; this.$.push(yyvstack[yysp]);
    break;

case 49:
    /*! Production::    regex : nonempty_regex_list */
    // Detect if the regex ends with a pure (Unicode) word;
    // we *do* consider escaped characters which are 'alphanumeric'
    // to be equivalent to their non-escaped version, hence these are
    // all valid 'words' for the 'easy keyword rules' option:
    //
    // - hello_kitty
    // - γεια_σου_γατούλα
    // - \u03B3\u03B5\u03B9\u03B1_\u03C3\u03BF\u03C5_\u03B3\u03B1\u03C4\u03BF\u03CD\u03BB\u03B1
    //
    // http://stackoverflow.com/questions/7885096/how-do-i-decode-a-string-with-escaped-unicode#12869914
    //
    // As we only check the *tail*, we also accept these as
    // 'easy keywords':
    //
    // - %options
    // - %foo-bar
    // - +++a:b:c1
    //
    // Note the dash in that last example: there the code will consider
    // `bar` to be the keyword, which is fine with us as we're only
    // interested in the trailing boundary and patching that one for
    // the `easy_keyword_rules` option.
    this.$ = yyvstack[yysp];
    if (yy.options.easy_keyword_rules) {
      // We need to 'protect' `eval` here as keywords are allowed
      // to contain double-quotes and other leading cruft.
      // `eval` *does* gobble some escapes (such as `\b`) but
      // we protect against that through a simple replace regex:
      // we're not interested in the special escapes' exact value
      // anyway.
      // It will also catch escaped escapes (`\\`), which are not
      // word characters either, so no need to worry about
      // `eval(str)` 'correctly' converting convoluted constructs
      // like '\\\\\\\\\\b' in here.
      this.$ = this.$
      .replace(/\\\\/g, '.')
      .replace(/"/g, '.')
      .replace(/\\c[A-Z]/g, '.')
      .replace(/\\[^xu0-9]/g, '.');
    
      try {
        // Convert Unicode escapes and other escapes to their literal characters
        // BEFORE we go and check whether this item is subject to the 
        // `easy_keyword_rules` option.  
        this.$ = eval('"' + this.$ + '"');
      }
      catch (ex) {
        this.warn('easy-keyword-rule FAIL on eval: ', ex);
    
        // make the next keyword test fail:
        this.$ = '.';
      }
      // a 'keyword' starts with an alphanumeric character,
      // followed by zero or more alphanumerics or digits:
      var re = new XRegExp('\\w[\\w\\d]*$');
      if (XRegExp.match(this.$, re)) {
        this.$ = yyvstack[yysp] + "\\b";
      } else {
        this.$ = yyvstack[yysp];
      }
    }
    break;

case 52:
    /*! Production::    nonempty_regex_list : regex_concat "|" regex_list */
    this.$ = yyvstack[yysp - 2] + '|' + yyvstack[yysp];
    break;

case 53:
    /*! Production::    nonempty_regex_list : "|" regex_list */
    this.$ = '|' + yyvstack[yysp];
    break;

case 57:
    /*! Production::    regex_base : "(" regex_list ")" */
    this.$ = '(' + yyvstack[yysp - 1] + ')';
    break;

case 58:
    /*! Production::    regex_base : SPECIAL_GROUP regex_list ")" */
    this.$ = yyvstack[yysp - 2] + yyvstack[yysp - 1] + ')';
    break;

case 59:
    /*! Production::    regex_base : "(" regex_list error */
    var l = yyvstack[yysp - 1];
    var ab = l.replace(/[\s\r\n]/g, ' ').substring(0, 32);
    yyparser.yyError("Seems you did not correctly bracket a lex rule regex part in '(...)' braces. Unterminated regex part: (" + ab, yyvstack[yysp - 1]);
    break;

case 60:
    /*! Production::    regex_base : SPECIAL_GROUP regex_list error */
    var l = yyvstack[yysp - 1];
    var ab = l.replace(/[\s\r\n]/g, ' ').substring(0, 32);
    yyparser.yyError("Seems you did not correctly bracket a lex rule regex part in '(...)' braces. Unterminated regex part: " + yyvstack[yysp - 2] + ab, yyvstack[yysp - 1]);
    break;

case 61:
    /*! Production::    regex_base : regex_base "+" */
    this.$ = yyvstack[yysp - 1] + '+';
    break;

case 62:
    /*! Production::    regex_base : regex_base "*" */
    this.$ = yyvstack[yysp - 1] + '*';
    break;

case 63:
    /*! Production::    regex_base : regex_base "?" */
    this.$ = yyvstack[yysp - 1] + '?';
    break;

case 64:
    /*! Production::    regex_base : "/" regex_base */
    this.$ = '(?=' + yyvstack[yysp] + ')';
    break;

case 65:
    /*! Production::    regex_base : "/!" regex_base */
    this.$ = '(?!' + yyvstack[yysp] + ')';
    break;

case 69:
    /*! Production::    regex_base : "." */
    this.$ = '.';
    break;

case 70:
    /*! Production::    regex_base : "^" */
    this.$ = '^';
    break;

case 71:
    /*! Production::    regex_base : "$" */
    this.$ = '$';
    break;

case 75:
    /*! Production::    any_group_regex : REGEX_SET_START regex_set REGEX_SET_END */
case 93:
    /*! Production::    extra_lexer_module_code : optional_module_code_chunk include_macro_code extra_lexer_module_code */
    this.$ = yyvstack[yysp - 2] + yyvstack[yysp - 1] + yyvstack[yysp];
    break;

case 76:
    /*! Production::    any_group_regex : REGEX_SET_START regex_set error */
    var l = yyvstack[yysp - 1];
    var ab = l.replace(/[\s\r\n]/g, ' ').substring(0, 32);
    yyparser.yyError("Seems you did not correctly bracket a lex rule regex set in '[...]' brackets. Unterminated regex set: " + yyvstack[yysp - 2] + ab, yyvstack[yysp - 1]);
    break;

case 80:
    /*! Production::    regex_set_atom : name_expansion */
    if (XRegExp._getUnicodeProperty(yyvstack[yysp].replace(/[{}]/g, ''))
        && yyvstack[yysp].toUpperCase() !== yyvstack[yysp]
    ) {
        // treat this as part of an XRegExp `\p{...}` Unicode 'General Category' Property cf. http://unicode.org/reports/tr18/#Categories
        this.$ = yyvstack[yysp];
    } else {
        this.$ = yyvstack[yysp];
    }
    //this.log("name expansion for: ", { name: $name_expansion, redux: $name_expansion.replace(/[{}]/g, ''), output: $$ });
    break;

case 83:
    /*! Production::    string : STRING_LIT */
    this.$ = prepareString(yyvstack[yysp]);
    break;

case 85:
    /*! Production::    options : OPTIONS option_list OPTIONS_END */
    // default action (generated by JISON):
    this.$ = yyvstack.slice(yysp - 2, yysp + 1);
    this._$ = yyparser.mergeLocationInfo(yysp - 2, yysp);
    break;

case 86:
    /*! Production::    option_list : option option_list */
    // default action (generated by JISON):
    this.$ = yyvstack.slice(yysp - 1, yysp + 1);
    this._$ = yyparser.mergeLocationInfo(yysp - 1, yysp);
    break;

case 88:
    /*! Production::    option : NAME */
    yy.options[yyvstack[yysp]] = true;
    break;

case 89:
    /*! Production::    option : NAME "=" OPTION_STRING_VALUE */
    yy.options[yyvstack[yysp - 2]] = yyvstack[yysp];
    break;

case 90:
    /*! Production::    option : NAME "=" OPTION_VALUE */
case 91:
    /*! Production::    option : NAME "=" NAME */
    yy.options[yyvstack[yysp - 2]] = parseValue(yyvstack[yysp]);
    break;

case 94:
    /*! Production::    include_macro_code : INCLUDE PATH */
    var fs = require('fs');
    var fileContent = fs.readFileSync(yyvstack[yysp], { encoding: 'utf-8' });
    // And no, we don't support nested '%include':
    this.$ = '\n// Included by Jison: ' + yyvstack[yysp] + ':\n\n' + fileContent + '\n\n// End Of Include by Jison: ' + yyvstack[yysp] + '\n\n';
    break;

case 95:
    /*! Production::    include_macro_code : INCLUDE error */
    yyparser.yyError("%include MUST be followed by a valid file path");
    break;

case 100:
                // error recovery reduction action (action generated by jison, 
                // using the user-specified `%code error_recovery_reduction` %{...%}
                // code chunk below.

                
                break;
            
}
},
table: bt({
  len: u([
  13,
  1,
  15,
  4,
  15,
  21,
  2,
  2,
  6,
  s,
  [11, 4],
  2,
  3,
  1,
  1,
  18,
  3,
  11,
  11,
  30,
  33,
  30,
  23,
  23,
  17,
  17,
  s,
  [29, 7],
  31,
  5,
  s,
  [29, 3],
  s,
  [12, 4],
  3,
  4,
  27,
  27,
  1,
  4,
  c,
  [36, 3],
  19,
  33,
  30,
  12,
  12,
  s,
  [29, 5],
  2,
  2,
  30,
  30,
  2,
  7,
  4,
  4,
  12,
  12,
  11,
  11,
  6,
  4,
  11,
  1,
  3,
  6,
  17,
  23,
  3,
  c,
  [27, 6],
  29,
  2,
  3,
  s,
  [2, 3],
  1,
  s,
  [3, 3],
  17,
  16,
  7,
  3,
  1,
  3,
  5,
  3,
  6,
  3,
  23,
  s,
  [18, 3],
  6,
  19,
  18,
  19,
  14,
  14,
  1,
  14,
  4,
  1,
  17,
  14,
  17,
  3,
  19,
  3,
  18,
  18
]),
  symbol: u([
  1,
  2,
  3,
  s,
  [19, 6, 1],
  37,
  41,
  44,
  46,
  1,
  c,
  [14, 11],
  47,
  48,
  73,
  77,
  1,
  2,
  19,
  45,
  c,
  [19, 15],
  9,
  10,
  s,
  [14, 4, 1],
  s,
  [27, 4, 1],
  33,
  35,
  36,
  61,
  s,
  [63, 5, 1],
  70,
  72,
  25,
  49,
  25,
  50,
  2,
  3,
  4,
  26,
  57,
  58,
  c,
  [46, 11],
  c,
  [11, 33],
  2,
  42,
  20,
  74,
  75,
  s,
  [1, 3],
  3,
  5,
  c,
  [85, 6],
  19,
  c,
  [86, 7],
  51,
  c,
  [119, 3],
  c,
  [61, 25],
  9,
  10,
  11,
  c,
  [44, 5],
  c,
  [18, 5],
  c,
  [49, 7],
  37,
  41,
  c,
  [134, 5],
  c,
  [30, 25],
  s,
  [62, 6, 1],
  c,
  [33, 5],
  7,
  s,
  [9, 9, 1],
  c,
  [36, 11],
  s,
  [34, 4, 1],
  41,
  71,
  2,
  c,
  [61, 7],
  c,
  [55, 7],
  c,
  [53, 8],
  c,
  [23, 23],
  c,
  [263, 12],
  c,
  [17, 22],
  c,
  [110, 29],
  c,
  [29, 197],
  s,
  [31, 7, 1],
  41,
  29,
  32,
  66,
  68,
  69,
  c,
  [123, 90],
  s,
  [19, 7, 1],
  c,
  [12, 38],
  c,
  [647, 3],
  c,
  [650, 4],
  s,
  [1, 5, 1],
  c,
  [599, 7],
  c,
  [525, 14],
  43,
  c,
  [27, 27],
  38,
  20,
  38,
  74,
  75,
  18,
  20,
  38,
  c,
  [661, 19],
  52,
  59,
  c,
  [607, 63],
  c,
  [30, 3],
  11,
  c,
  [712, 11],
  c,
  [12, 12],
  c,
  [493, 142],
  2,
  11,
  2,
  11,
  c,
  [203, 33],
  c,
  [840, 28],
  31,
  2,
  29,
  31,
  c,
  [530, 4],
  c,
  [7, 4],
  c,
  [4, 4],
  c,
  [439, 33],
  c,
  [1046, 14],
  c,
  [1096, 5],
  c,
  [452, 7],
  c,
  [21, 8],
  38,
  20,
  39,
  40,
  1,
  41,
  43,
  76,
  78,
  79,
  c,
  [409, 17],
  c,
  [405, 3],
  c,
  [890, 11],
  54,
  c,
  [1171, 8],
  7,
  20,
  60,
  c,
  [358, 157],
  c,
  [387, 30],
  31,
  c,
  [256, 3],
  20,
  c,
  [654, 3],
  c,
  [651, 4],
  41,
  77,
  c,
  [250, 3],
  c,
  [3, 4],
  c,
  [250, 16],
  2,
  4,
  c,
  [251, 13],
  53,
  2,
  3,
  23,
  41,
  55,
  56,
  77,
  2,
  6,
  8,
  6,
  c,
  [4, 3],
  c,
  [322, 4],
  c,
  [327, 4],
  c,
  [311, 7],
  41,
  43,
  c,
  [46, 14],
  c,
  [297, 9],
  1,
  c,
  [782, 10],
  c,
  [27, 7],
  c,
  [18, 36],
  c,
  [1518, 7],
  c,
  [24, 10],
  23,
  c,
  [61, 36],
  c,
  [37, 8],
  c,
  [436, 14],
  c,
  [14, 14],
  20,
  c,
  [15, 14],
  c,
  [521, 5],
  c,
  [251, 17],
  c,
  [204, 14],
  c,
  [282, 18],
  c,
  [247, 3],
  c,
  [118, 18],
  c,
  [277, 3],
  c,
  [219, 36]
]),
  type: u([
  s,
  [2, 11],
  0,
  0,
  1,
  c,
  [14, 13],
  0,
  0,
  c,
  [7, 4],
  c,
  [19, 18],
  c,
  [17, 14],
  c,
  [21, 5],
  0,
  c,
  [40, 6],
  c,
  [31, 15],
  s,
  [2, 34],
  c,
  [49, 21],
  c,
  [69, 48],
  c,
  [137, 8],
  c,
  [30, 30],
  c,
  [33, 28],
  c,
  [118, 20],
  c,
  [53, 23],
  c,
  [23, 20],
  c,
  [17, 34],
  s,
  [2, 224],
  c,
  [239, 202],
  c,
  [201, 24],
  c,
  [607, 80],
  c,
  [291, 188],
  c,
  [30, 36],
  c,
  [530, 61],
  c,
  [389, 26],
  c,
  [85, 32],
  s,
  [0, 9],
  c,
  [370, 203],
  c,
  [201, 39],
  c,
  [1410, 7],
  c,
  [1457, 13],
  c,
  [311, 26],
  c,
  [297, 11],
  c,
  [422, 80],
  s,
  [2, 191]
]),
  state: u([
  s,
  [1, 4, 1],
  11,
  10,
  15,
  18,
  c,
  [5, 3],
  19,
  20,
  21,
  23,
  28,
  29,
  34,
  33,
  40,
  42,
  44,
  45,
  48,
  49,
  53,
  55,
  c,
  [12, 4],
  56,
  57,
  c,
  [20, 6],
  61,
  63,
  c,
  [9, 7],
  64,
  c,
  [8, 7],
  65,
  c,
  [5, 4],
  66,
  c,
  [5, 4],
  70,
  67,
  68,
  78,
  49,
  81,
  82,
  84,
  c,
  [42, 8],
  61,
  61,
  70,
  91,
  68,
  92,
  45,
  96,
  98,
  97,
  100,
  102,
  c,
  [82, 7],
  103,
  108,
  110,
  112,
  115,
  116,
  122,
  123,
  98,
  97,
  125,
  c,
  [19, 8],
  127,
  45
]),
  mode: u([
  s,
  [2, 13],
  1,
  2,
  s,
  [1, 7],
  c,
  [8, 3],
  c,
  [14, 11],
  s,
  [1, 15],
  s,
  [2, 48],
  c,
  [53, 50],
  c,
  [129, 5],
  c,
  [52, 8],
  c,
  [118, 12],
  c,
  [25, 26],
  c,
  [29, 6],
  c,
  [71, 15],
  c,
  [52, 12],
  c,
  [218, 11],
  s,
  [1, 35],
  s,
  [2, 234],
  c,
  [236, 98],
  c,
  [97, 24],
  c,
  [24, 15],
  c,
  [374, 6],
  c,
  [142, 55],
  c,
  [470, 4],
  c,
  [86, 13],
  c,
  [72, 11],
  c,
  [565, 52],
  c,
  [446, 170],
  c,
  [310, 9],
  c,
  [202, 25],
  c,
  [29, 26],
  c,
  [310, 5],
  c,
  [241, 75],
  c,
  [141, 5],
  c,
  [80, 18],
  c,
  [861, 204],
  c,
  [191, 11],
  c,
  [236, 21],
  c,
  [728, 21],
  c,
  [246, 17],
  c,
  [403, 6],
  c,
  [276, 14],
  c,
  [279, 67],
  c,
  [346, 73],
  c,
  [452, 19],
  c,
  [298, 60],
  s,
  [2, 50]
]),
  goto: u([
  s,
  [6, 11],
  s,
  [8, 4],
  5,
  6,
  7,
  9,
  12,
  14,
  13,
  5,
  16,
  17,
  c,
  [14, 11],
  22,
  24,
  26,
  30,
  31,
  32,
  25,
  27,
  35,
  36,
  39,
  37,
  38,
  41,
  43,
  s,
  [41, 4],
  s,
  [14, 11],
  s,
  [15, 11],
  s,
  [16, 11],
  s,
  [17, 11],
  47,
  46,
  50,
  51,
  52,
  s,
  [23, 17],
  s,
  [7, 3],
  s,
  [9, 11],
  s,
  [49, 11],
  s,
  [54, 4],
  24,
  54,
  c,
  [114, 4],
  s,
  [54, 6],
  c,
  [120, 7],
  54,
  54,
  s,
  [51, 3],
  22,
  24,
  51,
  c,
  [25, 4],
  s,
  [51, 6],
  c,
  [25, 7],
  51,
  51,
  s,
  [56, 3],
  59,
  s,
  [56, 3],
  58,
  60,
  s,
  [56, 15],
  62,
  s,
  [56, 4],
  c,
  [52, 8],
  c,
  [46, 8],
  c,
  [15, 14],
  c,
  [218, 12],
  c,
  [12, 12],
  s,
  [66, 29],
  s,
  [68, 29],
  s,
  [69, 29],
  s,
  [70, 29],
  s,
  [71, 29],
  s,
  [72, 29],
  s,
  [73, 29],
  s,
  [74, 31],
  35,
  69,
  s,
  [83, 29],
  s,
  [84, 29],
  s,
  [81, 29],
  s,
  [10, 9],
  71,
  10,
  10,
  s,
  [18, 12],
  s,
  [11, 9],
  72,
  11,
  11,
  s,
  [20, 12],
  74,
  75,
  73,
  s,
  [38, 3],
  76,
  s,
  [94, 27],
  s,
  [95, 27],
  77,
  50,
  87,
  79,
  88,
  88,
  1,
  2,
  4,
  46,
  83,
  s,
  [46, 6],
  80,
  s,
  [46, 7],
  c,
  [565, 25],
  s,
  [55, 3],
  59,
  s,
  [55, 3],
  58,
  60,
  s,
  [55, 15],
  62,
  s,
  [55, 4],
  s,
  [53, 12],
  s,
  [50, 12],
  s,
  [61, 29],
  s,
  [62, 29],
  s,
  [63, 29],
  s,
  [67, 29],
  s,
  [82, 29],
  86,
  85,
  88,
  87,
  s,
  [64, 3],
  59,
  s,
  [64, 3],
  58,
  60,
  s,
  [64, 15],
  62,
  s,
  [64, 4],
  s,
  [65, 3],
  59,
  s,
  [65, 3],
  58,
  60,
  s,
  [65, 15],
  62,
  s,
  [65, 4],
  90,
  89,
  78,
  35,
  78,
  69,
  s,
  [79, 4],
  s,
  [80, 4],
  s,
  [19, 12],
  s,
  [21, 12],
  s,
  [12, 11],
  s,
  [13, 11],
  s,
  [41, 4],
  s,
  [42, 4],
  s,
  [85, 11],
  86,
  95,
  93,
  94,
  s,
  [99, 3],
  s,
  [22, 17],
  101,
  c,
  [1089, 13],
  104,
  105,
  s,
  [52, 12],
  s,
  [57, 29],
  s,
  [59, 29],
  s,
  [58, 29],
  s,
  [60, 29],
  s,
  [75, 29],
  s,
  [76, 29],
  77,
  77,
  107,
  75,
  106,
  89,
  89,
  90,
  90,
  91,
  91,
  3,
  92,
  13,
  98,
  98,
  109,
  s,
  [96, 3],
  s,
  [24, 17],
  111,
  s,
  [29, 14],
  113,
  114,
  117,
  13,
  119,
  118,
  120,
  121,
  s,
  [47, 3],
  s,
  [41, 4],
  s,
  [40, 3],
  s,
  [99, 3],
  s,
  [97, 3],
  124,
  c,
  [278, 13],
  27,
  27,
  126,
  s,
  [27, 15],
  s,
  [30, 18],
  s,
  [31, 18],
  s,
  [41, 4],
  s,
  [34, 11],
  128,
  s,
  [34, 7],
  s,
  [35, 18],
  s,
  [36, 19],
  s,
  [43, 14],
  s,
  [44, 14],
  129,
  s,
  [45, 14],
  s,
  [39, 3],
  76,
  93,
  s,
  [25, 17],
  s,
  [28, 14],
  s,
  [26, 17],
  131,
  75,
  130,
  s,
  [37, 19],
  s,
  [48, 3],
  s,
  [32, 18],
  s,
  [33, 18]
])
}),
defaultActions: bda({
  idx: u([
  0,
  s,
  [8, 5, 1],
  s,
  [17, 4, 1],
  s,
  [28, 8, 1],
  37,
  38,
  39,
  41,
  43,
  46,
  47,
  51,
  52,
  s,
  [56, 7, 1],
  s,
  [69, 10, 1],
  81,
  s,
  [84, 8, 1],
  s,
  [93, 4, 1],
  99,
  100,
  105,
  106,
  107,
  109,
  112,
  113,
  114,
  s,
  [116, 4, 1],
  121,
  s,
  [123, 4, 1],
  s,
  [128, 4, 1]
]),
  goto: u([
  6,
  41,
  s,
  [14, 4, 1],
  23,
  7,
  9,
  49,
  66,
  s,
  [68, 7, 1],
  83,
  84,
  81,
  18,
  20,
  94,
  95,
  1,
  2,
  53,
  50,
  61,
  62,
  63,
  67,
  82,
  79,
  80,
  19,
  21,
  12,
  13,
  41,
  42,
  85,
  86,
  22,
  52,
  57,
  59,
  58,
  60,
  75,
  76,
  77,
  89,
  90,
  91,
  3,
  96,
  24,
  47,
  41,
  40,
  97,
  30,
  31,
  41,
  35,
  36,
  43,
  44,
  45,
  93,
  25,
  28,
  26,
  37,
  48,
  32,
  33
])
}),
parseError: function parseError(str, hash, ExceptionClass) {
    if (hash.recoverable && typeof this.trace === 'function') {
        this.trace(str);
        hash.destroy();             // destroy... well, *almost*!
    } else {
        if (!ExceptionClass) {
            ExceptionClass = this.JisonParserError;
        }
        throw new ExceptionClass(str, hash);
    }
},
parse: function parse(input) {
    var self = this,
        stack = new Array(128),         // token stack: stores token which leads to state at the same index (column storage)
        sstack = new Array(128),        // state stack: stores states (column storage)

        vstack = new Array(128),        // semantic value stack
        lstack = new Array(128),        // location stack
        table = this.table,
        sp = 0;                         // 'stack pointer': index into the stacks

    var recovering = 0;                 // (only used when the grammar contains error recovery rules)
    var TERROR = this.TERROR,
        EOF = this.EOF,
        ERROR_RECOVERY_TOKEN_DISCARD_COUNT = (this.options.errorRecoveryTokenDiscardCount | 0) || 3;
    var NO_ACTION = [0, table.length /* ensures that anyone using this new state will fail dramatically! */];

    var lexer;
    if (this.__lexer__) {
        lexer = this.__lexer__;
    } else {
        lexer = this.__lexer__ = Object.create(this.lexer);
    }

    var sharedState_yy = {
        parseError: null,
        quoteName: null,
        lexer: null,
        parser: null,
        pre_parse: null,
        post_parse: null,
        pre_lex: null,
        post_lex: null
    };

    function shallow_copy(dst, src) {
        for (var k in src) {
            if (Object.prototype.hasOwnProperty.call(src, k)) {
                dst[k] = src[k];
            }
        }
    }
    function shallow_copy_noclobber(dst, src) {
        for (var k in src) {
            if (dst[k] === undefined && Object.prototype.hasOwnProperty.call(src, k)) {
                dst[k] = src[k];
            }
        }
    }

    // copy state
    shallow_copy(sharedState_yy, this.yy);

    sharedState_yy.lexer = lexer;
    sharedState_yy.parser = this;



















    // *Always* setup `yyError`, `YYRECOVERING`, `yyErrOk` and `yyClearIn` functions as it is paramount
    // to have *their* closure match ours -- if we only set them up once,
    // any subsequent `parse()` runs will fail in very obscure ways when
    // these functions are invoked in the user action code block(s) as
    // their closure will still refer to the `parse()` instance which set
    // them up. Hence we MUST set them up at the start of every `parse()` run!
    if (this.yyError) {
        this.yyError = function yyError(str /*, ...args */) {



            var error_rule_depth = (this.options.parserErrorsAreRecoverable ? locateNearestErrorRecoveryRule(state) : -1);
            var expected = this.collect_expected_token_set(state);
            var hash = this.constructParseErrorInfo(str, null, expected, (error_rule_depth >= 0));


            // Add any extra args to the hash under the name `extra_error_attributes`:
            var args = Array.prototype.slice.call(arguments, 1);
            if (args.length) {
                hash.extra_error_attributes = args;
            }

            var r = this.parseError(str, hash, this.JisonParserError);
            return r;
        };
    }






    lexer.setInput(input, sharedState_yy);

    var yyloc = lexer.yylloc;
    lstack[sp] = yyloc;
    vstack[sp] = null;
    sstack[sp] = 0;
    stack[sp] = 0;
    ++sp;





    var ranges = lexer.options && lexer.options.ranges;

    // Does the shared state override the default `parseError` that already comes with this instance?
    if (typeof sharedState_yy.parseError === 'function') {
        this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {
            if (!ExceptionClass) {
                ExceptionClass = this.JisonParserError;
            }
            return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);
        };
    } else {
        this.parseError = this.originalParseError;
    }

    // Does the shared state override the default `quoteName` that already comes with this instance?
    if (typeof sharedState_yy.quoteName === 'function') {
        this.quoteName = function quoteNameAlt(id_str) {
            return sharedState_yy.quoteName.call(this, id_str);
        };
    } else {
        this.quoteName = this.originalQuoteName;
    }

    // set up the cleanup function; make it an API so that external code can re-use this one in case of
    // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which
    // case this parse() API method doesn't come with a `finally { ... }` block any more!
    //
    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
    //       or else your `sharedState`, etc. references will be *wrong*!
    this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {
        var rv;

        if (invoke_post_methods) {
            var hash;

            if (sharedState_yy.post_parse || this.post_parse) {
                // create an error hash info instance: we re-use this API in a **non-error situation**
                // as this one delivers all parser internals ready for access by userland code.
                hash = this.constructParseErrorInfo(null /* no error! */, null /* no exception! */, null, false);
            }

            if (sharedState_yy.post_parse) {
                rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);
                if (typeof rv !== 'undefined') resultValue = rv;
            }
            if (this.post_parse) {
                rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);
                if (typeof rv !== 'undefined') resultValue = rv;
            }

            // cleanup:
            if (hash) {
                hash.destroy();
            }
        }

        if (this.__reentrant_call_depth > 1) return resultValue;        // do not (yet) kill the sharedState when this is a reentrant run.

        // clean up the lingering lexer structures as well:
        if (lexer.cleanupAfterLex) {
            lexer.cleanupAfterLex(do_not_nuke_errorinfos);
        }

        // prevent lingering circular references from causing memory leaks:
        if (sharedState_yy) {
            sharedState_yy.lexer = undefined;
            sharedState_yy.parser = undefined;
            if (lexer.yy === sharedState_yy) {
                lexer.yy = undefined;
            }
        }
        sharedState_yy = undefined;
        this.parseError = this.originalParseError;
        this.quoteName = this.originalQuoteName;

        // nuke the vstack[] array at least as that one will still reference obsoleted user values.
        // To be safe, we nuke the other internal stack columns as well...
        stack.length = 0;               // fastest way to nuke an array without overly bothering the GC
        sstack.length = 0;
        lstack.length = 0;
        vstack.length = 0;
        sp = 0;

        // nuke the error hash info instances created during this run.
        // Userland code must COPY any data/references
        // in the error hash instance(s) it is more permanently interested in.
        if (!do_not_nuke_errorinfos) {
            for (var i = this.__error_infos.length - 1; i >= 0; i--) {
                var el = this.__error_infos[i];
                if (el && typeof el.destroy === 'function') {
                    el.destroy();
                }
            }
            this.__error_infos.length = 0;
        }

        return resultValue;
    };

    // merge yylloc info into a new yylloc instance.
    //
    // `first_index` and `last_index` MAY be UNDEFINED/NULL or these are indexes into the `lstack[]` location stakc array.
    //
    // `first_yylloc` and `last_yylloc` MAY be UNDEFINED/NULL or explicit (custom or regular) `yylloc` instances, in which
    // case these override the corresponding first/last indexes.
    //
    // `dont_look_back` is an optional flag (default: FALSE), which instructs this merge operation NOT to search
    // through the parse location stack for a location, which would otherwise be used to construct the new (epsilon!)
    // yylloc info.
    //
    // Note: epsilon rule's yylloc situation is detected by passing both `first_index` and `first_yylloc` as UNDEFINED/NULL.
    this.mergeLocationInfo = function parser_mergeLocationInfo(first_index, last_index, first_yylloc, last_yylloc, dont_look_back) {
        var i1 = first_index | 0,
            i2 = last_index | 0;
        var l1 = first_yylloc,
            l2 = last_yylloc;
        var rv;

        // rules:
        // - first/last yylloc entries override first/last indexes

        if (!l1) {
            if (first_index != null) {
                for (var i = i1; i <= i2; i++) {
                    l1 = lstack[i];
                    if (l1) {
                        break;
                    }
                }
            }
        }

        if (!l2) {
            if (last_index != null) {
                for (var i = i2; i >= i1; i--) {
                    l2 = lstack[i];
                    if (l2) {
                        break;
                    }
                }
            }
        }

        // - detect if an epsilon rule is being processed and act accordingly:
        var start_with_epsilon = false;
        if (!l1 && first_index == null) {
            // epsilon rule span merger. With optional look-ahead in l2.
            start_with_epsilon = true;
            if (!dont_look_back) {
                for (var i = (i1 || sp) - 1; i >= 0; i--) {
                    l1 = lstack[i];
                    if (l1) {
                        break;
                    }
                }
            }
            if (!l1) {
                if (!l2) {
                    // when we still don't have any valid yylloc info, we're looking at an epsilon rule
                    // without look-ahead and no preceding terms and/or `dont_look_back` set:
                    // in that case we ca do nothing but return NULL/UNDEFINED:
                    return undefined;
                } else {
                    // shallow-copy L2: after all, we MAY be looking
                    // at unconventional yylloc info objects...
                    rv = {};
                    shallow_copy(rv, l2);
                    if (rv.range) {
                        // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:
                        rv.range = rv.range.slice(0);
                    }
                    return rv;
                }
            } else {
                // shallow-copy L1, then adjust first col/row 1 column past the end.
                rv = {};
                shallow_copy(rv, l1);
                rv.first_line = rv.last_line;
                rv.first_column = rv.last_column;
                if (rv.range) {
                    // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:
                    rv.range = rv.range.slice(0);
                    rv.range[0] = rv.range[1];
                }

                if (l2) {
                    // shallow-mixin L2, then adjust last col/row accordingly.
                    shallow_copy_noclobber(rv, l2);
                    rv.last_line = l2.last_line;
                    rv.last_column = l2.last_column;
                    if (rv.range && l2.range) {
                        rv.range[1] = l2.range[1];
                    }
                }
                return rv;
            }
        }

        if (!l1) {
            l1 = l2;
            l2 = null;
        }
        if (!l1) {
            return undefined;
        }

        rv = {};
        // shallow-copy L1|L2, before we try to adjust the yylloc values: after all, we MAY be looking
        // at unconventional yylloc info objects...
        shallow_copy(rv, l1);

        // first_line: ...,
        // first_column: ...,
        // last_line: ...,
        // last_column: ...,
        if (rv.range) {
            // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:
            rv.range = rv.range.slice(0);
        }

        if (l2) {
            shallow_copy_noclobber(rv, l2);
            rv.last_line = l2.last_line;
            rv.last_column = l2.last_column;
            if (rv.range && l2.range) {
                rv.range[1] = l2.range[1];
            }
        }

        return rv;
    };

    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
    //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!
    this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {
        var pei = {
            errStr: msg,
            exception: ex,
            text: lexer.match,
            value: lexer.yytext,
            token: this.describeSymbol(symbol) || symbol,
            token_id: symbol,
            line: lexer.yylineno,
            loc: lexer.yylloc,
            expected: expected,
            recoverable: recoverable,
            state: state,
            action: action,
            new_state: newState,
            symbol_stack: stack,
            state_stack: sstack,
            value_stack: vstack,
            location_stack: lstack,
            stack_pointer: sp,
            yy: sharedState_yy,
            lexer: lexer,
            parser: this,

            // and make sure the error info doesn't stay due to potential
            // ref cycle via userland code manipulations.
            // These would otherwise all be memory leak opportunities!
            //
            // Note that only array and object references are nuked as those
            // constitute the set of elements which can produce a cyclic ref.
            // The rest of the members is kept intact as they are harmless.
            destroy: function destructParseErrorInfo() {
                // remove cyclic references added to error info:
                // info.yy = null;
                // info.lexer = null;
                // info.value = null;
                // info.value_stack = null;
                // ...
                var rec = !!this.recoverable;
                for (var key in this) {
                    if (this.hasOwnProperty(key) && typeof key === 'object') {
                        this[key] = undefined;
                    }
                }
                this.recoverable = rec;
            }
        };
        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
        this.__error_infos.push(pei);
        return pei;
    };


    function lex() {
        var token = lexer.lex();
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }
        return token || EOF;
    }


    var symbol = 0;
    var preErrorSymbol = 0;
    var lastEofErrorStateDepth = 0;
    var state, action, r, t;
    var yyval = {
        $: true,
        _$: undefined,
        yy: sharedState_yy
    };
    var p, len, this_production;
    var newState;
    var retval = false;


    // Return the rule stack depth where the nearest error rule can be found.
    // Return -1 when no error recovery rule was found.
    function locateNearestErrorRecoveryRule(state) {
        var stack_probe = sp - 1;
        var depth = 0;

        // try to recover from error
        for (;;) {
            // check for error recovery rule in this state

            var t = table[state][TERROR] || NO_ACTION;
            if (t[0]) {
                // We need to make sure we're not cycling forever:
                // once we hit EOF, even when we `yyerrok()` an error, we must
                // prevent the core from running forever,
                // e.g. when parent rules are still expecting certain input to
                // follow after this, for example when you handle an error inside a set
                // of braces which are matched by a parent rule in your grammar.
                //
                // Hence we require that every error handling/recovery attempt
                // *after we've hit EOF* has a diminishing state stack: this means
                // we will ultimately have unwound the state stack entirely and thus
                // terminate the parse in a controlled fashion even when we have
                // very complex error/recovery code interplay in the core + user
                // action code blocks:

                if (symbol === EOF) {
                    if (!lastEofErrorStateDepth) {
                        lastEofErrorStateDepth = sp - 1 - depth;
                    } else if (lastEofErrorStateDepth <= sp - 1 - depth) {

                        --stack_probe; // popStack(1): [symbol, action]
                        state = sstack[stack_probe];
                        ++depth;
                        continue;
                    }
                }
                return depth;
            }
            if (state === 0 /* $accept rule */ || stack_probe < 1) {

                return -1; // No suitable error recovery rule available.
            }
            --stack_probe; // popStack(1): [symbol, action]
            state = sstack[stack_probe];
            ++depth;
        }
    }


    try {
        this.__reentrant_call_depth++;

        if (this.pre_parse) {
            this.pre_parse.call(this, sharedState_yy);
        }
        if (sharedState_yy.pre_parse) {
            sharedState_yy.pre_parse.call(this, sharedState_yy);
        }

        newState = sstack[sp - 1];
        for (;;) {
            // retrieve state number from top of stack
            state = newState;               // sstack[sp - 1];

            // use default actions if available
            if (this.defaultActions[state]) {
                action = 2;
                newState = this.defaultActions[state];
            } else {
                // The single `==` condition below covers both these `===` comparisons in a single
                // operation:
                //
                //     if (symbol === null || typeof symbol === 'undefined') ...
                if (!symbol) {
                    symbol = lex();
                }
                // read action for current state and first input
                t = (table[state] && table[state][symbol]) || NO_ACTION;
                newState = t[1];
                action = t[0];




                // handle parse error
                if (!action) {
                    // first see if there's any chance at hitting an error recovery rule:
                    var error_rule_depth = locateNearestErrorRecoveryRule(state);
                    var errStr = null;
                    var errSymbolDescr = (this.describeSymbol(symbol) || symbol);
                    var expected = this.collect_expected_token_set(state);

                    if (!recovering) {
                        // Report error
                        if (typeof lexer.yylineno === 'number') {
                            errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ': ';
                        } else {
                            errStr = 'Parse error: ';
                        }
                        if (lexer.showPosition) {
                            errStr += '\n' + lexer.showPosition(79 - 10, 10) + '\n';
                        }
                        if (expected.length) {
                            errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;
                        } else {
                            errStr += 'Unexpected ' + errSymbolDescr;
                        }
                        p = this.constructParseErrorInfo(errStr, null, expected, (error_rule_depth >= 0));
                        r = this.parseError(p.errStr, p, this.JisonParserError);


                        // Protect against overly blunt userland `parseError` code which *sets* 
                        // the `recoverable` flag without properly checking first:
                        // we always terminate the parse when there's no recovery rule available anyhow!
                        if (!p.recoverable || error_rule_depth < 0) {
                            retval = r;
                            break;
                        } else {
                            // TODO: allow parseError callback to edit symbol and or state at the start of the error recovery process...
                        }
                    }



                    // just recovered from another error
                    if (recovering === ERROR_RECOVERY_TOKEN_DISCARD_COUNT && error_rule_depth >= 0) {
                        // SHIFT current lookahead and grab another
                        stack[sp] = symbol;
                        vstack[sp] = lexer.yytext;
                        lstack[sp] = lexer.yylloc;
                        sstack[sp] = newState; // push state
                        ++sp;
                        // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:



                        yyloc = lexer.yylloc;

                        symbol = lex();

                        if (error_rule_depth >= 0) {
                            // correct for the ERROR SHIFT above by adjusting the REDUCE amount:
                            error_rule_depth++;
                        }


                    }

                    // try to recover from error
                    if (error_rule_depth < 0) {
                        //assert(recovering);

                        // barf a fatal hairball when we're out of look-ahead symbols and none hit a match
                        // while we are still busy recovering from another error:
                        var po = this.__error_infos[this.__error_infos.length - 1];
                        if (!po) {
                            p = this.constructParseErrorInfo('Parsing halted while starting to recover from another error.', null, expected, false);
                        } else {
                            p = this.constructParseErrorInfo('Parsing halted while starting to recover from another error. Previous error which resulted in this fatal result: ' + po.errStr, null, expected, false);
                            p.extra_error_attributes = po;
                        }
                        retval = this.parseError(p.errStr, p, this.JisonParserError);
                        break;
                    }

                    preErrorSymbol = (symbol === TERROR ? 0 : symbol); // save the lookahead token
                    symbol = TERROR;            // insert generic error symbol as new lookahead

                    // REDUCE/COMBINE the pushed terms/tokens to a new ERROR token:
                    stack[sp] = preErrorSymbol;
                    vstack[sp] = lexer.yytext;
                    lstack[sp] = lexer.yylloc;
                    sstack[sp] = newState || NO_ACTION[1];
                    sp++;
                    error_rule_depth++;

                    yyval.$ = undefined;
                    yyval._$ = undefined;

                    len = error_rule_depth;

                    r = this.performAction.call(yyval, yyloc, NO_ACTION[1], sp - 1, len, vstack, lstack);

                    if (typeof r !== 'undefined') {
                        retval = r;
                        break;
                    }

                    // pop off stack
                    sp -= len;

                    stack[sp] = TERROR;
                    vstack[sp] = yyval.$;
                    lstack[sp] = yyval._$;
                    // goto new state = table[STATE][NONTERMINAL]

                    newState = sstack[sp - 1];

                    if (this.defaultActions[newState]) {
                        sstack[sp] = this.defaultActions[newState];
                    } else {
                        t = (table[newState] && table[newState][symbol]) || NO_ACTION;
                        sstack[sp] = t[1];
                    }

                    // allow N (default: 3) real symbols to be shifted before reporting a new error
                    recovering = ERROR_RECOVERY_TOKEN_DISCARD_COUNT;



                    continue;
                }


            }










            switch (action) {
            // catch misc. parse failures:
            default:
                // this shouldn't happen, unless resolve defaults are off
                if (action instanceof Array) {
                    p = this.constructParseErrorInfo('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol, null, null, false);
                    retval = this.parseError(p.errStr, p, this.JisonParserError);
                    break;
                }
                // Another case of better safe than sorry: in case state transitions come out of another error recovery process
                // or a buggy LUT (LookUp Table):
                p = this.constructParseErrorInfo('Parsing halted. No viable error recovery approach available due to internal system failure.', null, null, false);
                retval = this.parseError(p.errStr, p, this.JisonParserError);
                break;

            // shift:
            case 1:
                stack[sp] = symbol;
                vstack[sp] = lexer.yytext;
                lstack[sp] = lexer.yylloc;
                sstack[sp] = newState; // push state
                ++sp;
                symbol = 0;
                if (!preErrorSymbol) { // normal execution / no error
                    // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:



                    yyloc = lexer.yylloc;

                    if (recovering > 0) {
                        recovering--;

                    }
                } else {
                    // error just occurred, resume old lookahead f/ before error, *unless* that drops us straight back into error mode:
                    symbol = preErrorSymbol;
                    preErrorSymbol = 0;

                    // read action for current state and first input
                    t = (table[newState] && table[newState][symbol]) || NO_ACTION;
                    if (!t[0] || symbol === TERROR) {
                        // forget about that symbol and move forward: this wasn't a 'forgot to insert' error type where
                        // (simple) stuff might have been missing before the token which caused the error we're
                        // recovering from now...
                        //
                        // Also check if the LookAhead symbol isn't the ERROR token we set as part of the error
                        // recovery, for then this we would we idling (cycling) on the error forever.
                        // Yes, this does not take into account the possibility that the *lexer* may have
                        // produced a *new* TERROR token all by itself, but that would be a very peculiar grammar!

                        symbol = 0;
                    }
                }

                continue;

            // reduce:
            case 2:
                this_production = this.productions_[newState - 1];  // `this.productions_[]` is zero-based indexed while states start from 1 upwards...
                len = this_production[1];



                r = this.performAction.call(yyval, yyloc, newState, sp - 1, len, vstack, lstack);

                if (typeof r !== 'undefined') {
                    retval = r;
                    break;
                }

                // pop off stack
                sp -= len;

                // don't overwrite the `symbol` variable: use a local var to speed things up:
                var ntsymbol = this_production[0];    // push nonterminal (reduce)
                stack[sp] = ntsymbol;
                vstack[sp] = yyval.$;
                lstack[sp] = yyval._$;
                // goto new state = table[STATE][NONTERMINAL]
                newState = table[sstack[sp - 1]][ntsymbol];
                sstack[sp] = newState;
                ++sp;

                continue;

            // accept:
            case 3:
                retval = true;
                // Return the `$accept` rule's `$$` result, if available.
                //
                // Also note that JISON always adds this top-most `$accept` rule (with implicit,
                // default, action):
                //
                //     $accept: <startSymbol> $end
                //                  %{ $$ = $1; @$ = @1; %}
                //
                // which, combined with the parse kernel's `$accept` state behaviour coded below,
                // will produce the `$$` value output of the <startSymbol> rule as the parse result,
                // IFF that result is *not* `undefined`. (See also the parser kernel code.)
                //
                // In code:
                //
                //                  %{
                //                      @$ = @1;            // if location tracking support is included
                //                      if (typeof $1 !== 'undefined')
                //                          return $1;
                //                      else
                //                          return true;           // the default parse result if the rule actions don't produce anything
                //                  %}
                sp--;
                if (typeof vstack[sp] !== 'undefined') {
                    retval = vstack[sp];
                }
                break;
            }

            // break out of loop: we accept or fail with error
            break;
        }
    } catch (ex) {
        // report exceptions through the parseError callback too, but keep the exception intact
        // if it is a known parser or lexer error which has been thrown by parseError() already:
        if (ex instanceof this.JisonParserError) {
            throw ex;
        }
        else if (lexer && typeof lexer.JisonLexerError === 'function' && ex instanceof lexer.JisonLexerError) {
            throw ex;
        }
        else {
            p = this.constructParseErrorInfo('Parsing aborted due to exception.', ex, null, false);
            retval = this.parseError(p.errStr, p, this.JisonParserError);
        }
    } finally {
        retval = this.cleanupAfterParse(retval, true, true);
        this.__reentrant_call_depth--;
    }

    return retval;
},
yyError: 1
};
parser.originalParseError = parser.parseError;
parser.originalQuoteName = parser.quoteName;

var XRegExp = require('xregexp');       // for helping out the `%options xregexp` in the lexer

function encodeRE(s) {
    return s.replace(/([.*+?^${}()|\[\]\/\\])/g, '\\$1').replace(/\\\\u([a-fA-F0-9]{4})/g, '\\u$1');
}

function prepareString(s) {
    // unescape slashes
    s = s.replace(/\\\\/g, "\\");
    s = encodeRE(s);
    return s;
}

// convert string value to number or boolean value, when possible
// (and when this is more or less obviously the intent)
// otherwise produce the string itself as value.
function parseValue(v) {
    if (v === 'false') {
        return false;
    }
    if (v === 'true') {
        return true;
    }
    // http://stackoverflow.com/questions/175739/is-there-a-built-in-way-in-javascript-to-check-if-a-string-is-a-valid-number
    // Note that the `v` check ensures that we do not convert `undefined`, `null` and `''` (empty string!)
    if (v && !isNaN(v)) {
        var rv = +v;
        if (isFinite(rv)) {
            return rv;
        }
    }
    return v;
}

parser.warn = function p_warn() {
    console.warn.apply(console, arguments);
};

parser.log = function p_log() {
    console.log.apply(console, arguments);
};
var lexer = function() {
  function JisonLexerError(msg, hash) {
    Object.defineProperty(this, 'name', {
      enumerable: false,
      writable: false,
      value: 'JisonLexerError'
    });

    if (msg == null)
      msg = '???';

    Object.defineProperty(this, 'message', {
      enumerable: false,
      writable: true,
      value: msg
    });

    this.hash = hash;
    var stacktrace;

    if (hash && hash.exception instanceof Error) {
      var ex2 = hash.exception;
      this.message = ex2.message || msg;
      stacktrace = ex2.stack;
    }

    if (!stacktrace) {
      if (Error.hasOwnProperty('captureStackTrace')) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        stacktrace = new Error(msg).stack;
      }
    }

    if (stacktrace) {
      Object.defineProperty(this, 'stack', {
        enumerable: false,
        writable: false,
        value: stacktrace
      });
    }
  }

  if (typeof Object.setPrototypeOf === 'function') {
    Object.setPrototypeOf(JisonLexerError.prototype, Error.prototype);
  } else {
    JisonLexerError.prototype = Object.create(Error.prototype);
  }

  JisonLexerError.prototype.constructor = JisonLexerError;
  JisonLexerError.prototype.name = 'JisonLexerError';

  var lexer = {
    EOF: 1,
    ERROR: 2,
    __currentRuleSet__: null,
    __error_infos: [],
    __decompressed: false,
    done: false,
    _backtrack: false,
    _input: '',
    _more: false,
    _signaled_error_token: false,
    conditionStack: [],
    match: '',
    matched: '',
    matches: false,
    yytext: '',
    offset: 0,
    yyleng: 0,
    yylineno: 0,
    yylloc: null,

    constructLexErrorInfo: function lexer_constructLexErrorInfo(msg, recoverable) {
      var pei = {
        errStr: msg,
        recoverable: !!recoverable,
        text: this.match,
        token: null,
        line: this.yylineno,
        loc: this.yylloc,
        yy: this.yy,
        lexer: this,

        destroy: function destructLexErrorInfo() {
          var rec = !!this.recoverable;

          for (var key in this) {
            if (this.hasOwnProperty(key) && typeof key === 'object') {
              this[key] = undefined;
            }
          }

          this.recoverable = rec;
        }
      };

      this.__error_infos.push(pei);
      return pei;
    },

    parseError: function lexer_parseError(str, hash, ExceptionClass) {
      if (!ExceptionClass) {
        ExceptionClass = this.JisonLexerError;
      }

      if (this.yy) {
        if (this.yy.parser && typeof this.yy.parser.parseError === 'function') {
          return this.yy.parser.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
        } else if (typeof this.yy.parseError === 'function') {
          return this.yy.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
        }
      }

      throw new ExceptionClass(str, hash);
    },

    yyerror: function yyError(str) {
      var lineno_msg = '';

      if (this.options.trackPosition) {
        lineno_msg = ' on line ' + (this.yylineno + 1);
      }

      var p = this.constructLexErrorInfo(
        'Lexical error' + lineno_msg + ': ' + str,
        this.options.lexerErrorsAreRecoverable
      );

      var args = Array.prototype.slice.call(arguments, 1);

      if (args.length) {
        p.extra_error_attributes = args;
      }

      return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
    },

    cleanupAfterLex: function lexer_cleanupAfterLex(do_not_nuke_errorinfos) {
      var rv;
      this.setInput('', {});

      if (!do_not_nuke_errorinfos) {
        for (var i = this.__error_infos.length - 1; i >= 0; i--) {
          var el = this.__error_infos[i];

          if (el && typeof el.destroy === 'function') {
            el.destroy();
          }
        }

        this.__error_infos.length = 0;
      }

      return this;
    },

    clear: function lexer_clear() {
      this.yytext = '';
      this.yyleng = 0;
      this.match = '';
      this.matches = false;
      this._more = false;
      this._backtrack = false;
      var col = (this.yylloc ? this.yylloc.last_column : 0);

      this.yylloc = {
        first_line: this.yylineno + 1,
        first_column: col,
        last_line: this.yylineno + 1,
        last_column: col,
        range: [this.offset, this.offset]
      };
    },

    setInput: function lexer_setInput(input, yy) {
      this.yy = yy || this.yy || {};

      if (!this.__decompressed) {
        var rules = this.rules;

        for (var i = 0, len = rules.length; i < len; i++) {
          var rule_re = rules[i];

          if (typeof rule_re === 'number') {
            rules[i] = rules[rule_re];
          }
        }

        var conditions = this.conditions;

        for (var k in conditions) {
          var spec = conditions[k];
          var rule_ids = spec.rules;
          var len = rule_ids.length;
          var rule_regexes = new Array(len + 1);
          var rule_new_ids = new Array(len + 1);

          for (var i = 0; i < len; i++) {
            var idx = rule_ids[i];
            var rule_re = rules[idx];
            rule_regexes[i + 1] = rule_re;
            rule_new_ids[i + 1] = idx;
          }

          spec.rules = rule_new_ids;
          spec.__rule_regexes = rule_regexes;
          spec.__rule_count = len;
        }

        this.__decompressed = true;
      }

      this._input = input || '';
      this.clear();
      this._signaled_error_token = false;
      this.done = false;
      this.yylineno = 0;
      this.matched = '';
      this.conditionStack = ['INITIAL'];
      this.__currentRuleSet__ = null;

      this.yylloc = {
        first_line: 1,
        first_column: 0,
        last_line: 1,
        last_column: 0,
        range: [0, 0]
      };

      this.offset = 0;
      return this;
    },

    pushInput: function lexer_pushInput(input, label, options) {
      options = options || {};
      this._input = input || '';
      this.clear();
      this.done = false;
      this.yylineno = 0;
      this.matched = '';

      this.yylloc = {
        first_line: 1,
        first_column: 0,
        last_line: 1,
        last_column: 0,
        range: [0, 0]
      };

      this.offset = 0;
      return this;
    },

    input: function lexer_input() {
      if (!this._input) {
        return null;
      }

      var ch = this._input[0];
      this.yytext += ch;
      this.yyleng++;
      this.offset++;
      this.match += ch;
      this.matched += ch;
      var slice_len = 1;
      var lines = false;

      if (ch === '\n') {
        lines = true;
      } else if (ch === '\r') {
        lines = true;
        var ch2 = this._input[1];

        if (ch2 === '\n') {
          slice_len++;
          ch += ch2;
          this.yytext += ch2;
          this.yyleng++;
          this.offset++;
          this.match += ch2;
          this.matched += ch2;
          this.yylloc.range[1]++;
        }
      }

      if (lines) {
        this.yylineno++;
        this.yylloc.last_line++;
        this.yylloc.last_column = 0;
      } else {
        this.yylloc.last_column++;
      }

      this.yylloc.range[1]++;
      this._input = this._input.slice(slice_len);
      return ch;
    },

    unput: function lexer_unput(ch) {
      var len = ch.length;
      var lines = ch.split(/(?:\r\n?|\n)/g);
      this._input = ch + this._input;
      this.yytext = this.yytext.substr(0, this.yytext.length - len);
      this.yyleng = this.yytext.length;
      this.offset -= len;
      this.match = this.match.substr(0, this.match.length - len);
      this.matched = this.matched.substr(0, this.matched.length - len);

      if (lines.length > 1) {
        this.yylineno -= lines.length - 1;
        this.yylloc.last_line = this.yylineno + 1;
        var pre = this.match;
        var pre_lines = pre.split(/(?:\r\n?|\n)/g);

        if (pre_lines.length === 1) {
          pre = this.matched;
          pre_lines = pre.split(/(?:\r\n?|\n)/g);
        }

        this.yylloc.last_column = pre_lines[pre_lines.length - 1].length;
      } else {
        this.yylloc.last_column -= len;
      }

      this.yylloc.range[1] = this.yylloc.range[0] + this.yyleng;
      this.done = false;
      return this;
    },

    more: function lexer_more() {
      this._more = true;
      return this;
    },

    reject: function lexer_reject() {
      if (this.options.backtrack_lexer) {
        this._backtrack = true;
      } else {
        var lineno_msg = '';

        if (this.options.trackPosition) {
          lineno_msg = ' on line ' + (this.yylineno + 1);
        }

        var pos_str = this.showPosition();

        if (pos_str && pos_str[0] !== '\n') {
          pos_str = '\n' + pos_str;
        }

        var p = this.constructLexErrorInfo(
          'Lexical error' + lineno_msg + ': You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).' + pos_str,
          false
        );

        this._signaled_error_token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
      }

      return this;
    },

    less: function lexer_less(n) {
      return this.unput(this.match.slice(n));
    },

    pastInput: function lexer_pastInput(maxSize, maxLines) {
      var past = this.matched.substring(0, this.matched.length - this.match.length);

      if (maxSize < 0)
        maxSize = past.length;
      else if (!maxSize)
        maxSize = 20;

      if (maxLines < 0)
        maxLines = past.length;
      else if (!maxLines)
        maxLines = 1;

      past = past.substr(-maxSize * 2 - 2);
      var a = past.replace(/\r\n|\r/g, '\n').split('\n');
      a = a.slice(-maxLines);
      past = a.join('\n');

      if (past.length > maxSize) {
        past = '...' + past.substr(-maxSize);
      }

      return past;
    },

    upcomingInput: function lexer_upcomingInput(maxSize, maxLines) {
      var next = this.match;

      if (maxSize < 0)
        maxSize = next.length + this._input.length;
      else if (!maxSize)
        maxSize = 20;

      if (maxLines < 0)
        maxLines = maxSize;
      else if (!maxLines)
        maxLines = 1;

      if (next.length < maxSize * 2 + 2) {
        next += this._input.substring(0, maxSize * 2 + 2);
      }

      var a = next.replace(/\r\n|\r/g, '\n').split('\n');
      a = a.slice(0, maxLines);
      next = a.join('\n');

      if (next.length > maxSize) {
        next = next.substring(0, maxSize) + '...';
      }

      return next;
    },

    showPosition: function lexer_showPosition(maxPrefix, maxPostfix) {
      var pre = this.pastInput(maxPrefix).replace(/\s/g, ' ');
      var c = new Array(pre.length + 1).join('-');
      return pre + this.upcomingInput(maxPostfix).replace(/\s/g, ' ') + '\n' + c + '^';
    },

    describeYYLLOC: function lexer_describe_yylloc(yylloc, display_range_too) {
      var l1 = yylloc.first_line;
      var l2 = yylloc.last_line;
      var c1 = yylloc.first_column;
      var c2 = yylloc.last_column;
      var dl = l2 - l1;
      var dc = c2 - c1;
      var rv;

      if (dl === 0) {
        rv = 'line ' + l1 + ', ';

        if (dc <= 1) {
          rv += 'column ' + c1;
        } else {
          rv += 'columns ' + c1 + ' .. ' + c2;
        }
      } else {
        rv = 'lines ' + l1 + '(column ' + c1 + ') .. ' + l2 + '(column ' + c2 + ')';
      }

      if (yylloc.range && display_range_too) {
        var r1 = yylloc.range[0];
        var r2 = yylloc.range[1] - 1;

        if (r2 <= r1) {
          rv += ' {String Offset: ' + r1 + '}';
        } else {
          rv += ' {String Offset range: ' + r1 + ' .. ' + r2 + '}';
        }
      }

      return rv;
    },

    test_match: function lexer_test_match(match, indexed_rule) {
      var token, lines, backup, match_str, match_str_len;

      if (this.options.backtrack_lexer) {
        backup = {
          yylineno: this.yylineno,

          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.yylloc.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column,
            range: this.yylloc.range.slice(0)
          },

          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        };
      }

      match_str = match[0];
      match_str_len = match_str.length;
      lines = match_str.split(/(?:\r\n?|\n)/g);

      if (lines.length > 1) {
        this.yylineno += lines.length - 1;
        this.yylloc.last_line = this.yylineno + 1;
        this.yylloc.last_column = lines[lines.length - 1].length;
      } else {
        this.yylloc.last_column += match_str_len;
      }

      this.yytext += match_str;
      this.match += match_str;
      this.matches = match;
      this.yyleng = this.yytext.length;
      this.yylloc.range[1] += match_str_len;
      this.offset += match_str_len;
      this._more = false;
      this._backtrack = false;
      this._input = this._input.slice(match_str_len);
      this.matched += match_str;

      token = this.performAction.call(
        this,
        this.yy,
        this,
        indexed_rule,
        this.conditionStack[this.conditionStack.length - 1]
      );

      if (this.done && this._input) {
        this.done = false;
      }

      if (token) {
        return token;
      } else if (this._backtrack) {
        for (var k in backup) {
          this[k] = backup[k];
        }

        this.__currentRuleSet__ = null;
        return false;
      } else if (this._signaled_error_token) {
        token = this._signaled_error_token;
        this._signaled_error_token = false;
        return token;
      }

      return false;
    },

    next: function lexer_next() {
      if (this.done) {
        this.clear();
        return this.EOF;
      }

      if (!this._input) {
        this.done = true;
      }

      var token, match, tempMatch, index;

      if (!this._more) {
        this.clear();
      }

      var spec = this.__currentRuleSet__;

      if (!spec) {
        spec = this.__currentRuleSet__ = this._currentRules();

        if (!spec || !spec.rules) {
          var lineno_msg = '';

          if (this.options.trackPosition) {
            lineno_msg = ' on line ' + (this.yylineno + 1);
          }

          var pos_str = this.showPosition();

          if (pos_str && pos_str[0] !== '\n') {
            pos_str = '\n' + pos_str;
          }

          var p = this.constructLexErrorInfo(
            'Internal lexer engine error' + lineno_msg + ': The lex grammar programmer pushed a non-existing condition name "' + this.topState() + '"; this is a fatal error and should be reported to the application programmer team!' + pos_str,
            false
          );

          return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
        }
      }

      var rule_ids = spec.rules;
      var regexes = spec.__rule_regexes;
      var len = spec.__rule_count;

      for (var i = 1; i <= len; i++) {
        tempMatch = this._input.match(regexes[i]);

        if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
          match = tempMatch;
          index = i;

          if (this.options.backtrack_lexer) {
            token = this.test_match(tempMatch, rule_ids[i]);

            if (token !== false) {
              return token;
            } else if (this._backtrack) {
              match = undefined;
              continue;
            } else {
              return false;
            }
          } else if (!this.options.flex) {
            break;
          }
        }
      }

      if (match) {
        token = this.test_match(match, rule_ids[index]);

        if (token !== false) {
          return token;
        }

        return false;
      }

      if (!this._input) {
        this.done = true;
        this.clear();
        return this.EOF;
      } else {
        var lineno_msg = '';

        if (this.options.trackPosition) {
          lineno_msg = ' on line ' + (this.yylineno + 1);
        }

        var pos_str = this.showPosition();

        if (pos_str && pos_str[0] !== '\n') {
          pos_str = '\n' + pos_str;
        }

        var p = this.constructLexErrorInfo(
          'Lexical error' + lineno_msg + ': Unrecognized text.' + pos_str,
          this.options.lexerErrorsAreRecoverable
        );

        token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;

        if (token === this.ERROR) {
          if (!this.match.length) {
            this.input();
          }
        }

        return token;
      }
    },

    lex: function lexer_lex() {
      var r;

      if (typeof this.options.pre_lex === 'function') {
        r = this.options.pre_lex.call(this);
      }

      while (!r) {
        r = this.next();
      }

      if (typeof this.options.post_lex === 'function') {
        r = this.options.post_lex.call(this, r) || r;
      }

      return r;
    },

    begin: function lexer_begin(condition) {
      return this.pushState(condition);
    },

    pushState: function lexer_pushState(condition) {
      this.conditionStack.push(condition);
      this.__currentRuleSet__ = null;
      return this;
    },

    popState: function lexer_popState() {
      var n = this.conditionStack.length - 1;

      if (n > 0) {
        this.__currentRuleSet__ = null;
        return this.conditionStack.pop();
      } else {
        return this.conditionStack[0];
      }
    },

    topState: function lexer_topState(n) {
      n = this.conditionStack.length - 1 - Math.abs(n || 0);

      if (n >= 0) {
        return this.conditionStack[n];
      } else {
        return 'INITIAL';
      }
    },

    _currentRules: function lexer__currentRules() {
      if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
        return this.conditions[this.conditionStack[this.conditionStack.length - 1]];
      } else {
        return this.conditions['INITIAL'];
      }
    },

    stateStackSize: function lexer_stateStackSize() {
      return this.conditionStack.length;
    },

    options: {
      xregexp: true,
      ranges: true,
      trackPosition: true,
      easy_keyword_rules: true
    },

    JisonLexerError: JisonLexerError,

    performAction: function lexer__performAction(yy, yy_, yyrulenumber, YY_START) {
      var YYSTATE = YY_START;

      switch (yyrulenumber) {
      case 7:
        yy.depth++;
        return 3;
        break;
      case 8:
        if (yy.depth == 0) {
          this.popState();
          this.pushState('trail');
        } else {
          yy.depth--;
        }

        return 4;
        break;
      case 10:
        this.popState();
        return 6;
        break;
      case 13:
        break;
      case 14:
        break;
      case 15:
        this.pushState('indented');
        break;
      case 16:
        this.popState();
        this.pushState('code');
        return 19;
        break;
      case 17:
        return 36;
        break;
      case 20:
        yy_.yytext = this.matches[1];
        return 39;
        break;
      case 21:
        yy_.yytext = this.matches[1];
        return 39;
        break;
      case 22:
        break;
      case 23:
        break;
      case 25:
        break;
      case 26:
        this.popState();
        return 38;
        break;
      case 27:
        break;
      case 29:
        this.popState();
        break;
      case 30:
        break;
      case 31:
        this.popState();
        this.unput(yy_.yytext);
        break;
      case 32:
        this.popState();
        break;
      case 33:
        yy.depth = 0;
        this.pushState('action');
        return 3;
        break;
      case 34:
        this.pushState('trail');
        yy_.yytext = this.matches[1];
        return 23;
        break;
      case 35:
        yy_.yytext = this.matches[1];
        return 23;
        break;
      case 36:
        this.pushState('trail');
        this.pushState('path');
        return 41;
        break;
      case 37:
        this.popState();
        return 23;
        break;
      case 38:
        this.pushState('macro');
        return 20;
        break;
      case 39:
        this.popState();
        break;
      case 40:
        return 36;
        break;
      case 41:
        break;
      case 42:
        break;
      case 43:
        yy_.yytext = this.matches[1];
        yy_.yytext = yy_.yytext.replace(/\\"/g, '"');
        return 35;
        break;
      case 44:
        yy_.yytext = this.matches[1];
        yy_.yytext = yy_.yytext.replace(/\\'/g, '\'');
        return 35;
        break;
      case 45:
        this.pushState('set');
        return 30;
        break;
      case 58:
        this.pushState('conditions');
        return 5;
        break;
      case 59:
        return 28;
        break;
      case 60:
        return 14;
        break;
      case 62:
        yy_.yytext = yy_.yytext.replace(/^\\/g, '');
        return 33;
        break;
      case 65:
        this.pushState('options');
        return 37;
        break;
      case 66:
        this.pushState('start_condition');
        return 21;
        break;
      case 67:
        this.pushState('start_condition');
        return 22;
        break;
      case 68:
        this.pushState('path');
        return 41;
        break;
      case 69:
        var l0 = Math.max(0, yy_.yylloc.last_column - yy_.yylloc.first_column);
        var l2 = 19;
        var l1 = Math.min(79 - 4 - l0 - l2, yy_.yylloc.first_column, 0);

        this.warn(
          'LEX: ignoring unsupported lexer option',
          dquote(yy_.yytext),
          'while lexing in',
          this.topState(),
          'state:\n' + indent(this.showPosition(l1, l2), 4)
        );

        yy_.yytext = [this.matches[1], this.matches[2].trim()];
        return 24;
        break;
      case 70:
        this.pushState('rules');
        return 19;
        break;
      case 78:
        this.popState();
        return 31;
        break;
      case 80:
        return 43;
        break;
      case 81:
        this.popState();
        this.unput(yy_.yytext);
        break;
      case 82:
        yy_.yytext = this.matches[1];
        this.popState();
        return 42;
        break;
      case 83:
        yy_.yytext = this.matches[1];
        this.popState();
        return 42;
        break;
      case 84:
        break;
      case 85:
        this.popState();
        return 42;
        break;
      case 86:
        var l0 = Math.max(0, yy_.yylloc.last_column - yy_.yylloc.first_column);
        var l2 = 39;
        var l1 = Math.min(79 - 4 - l0 - l2, yy_.yylloc.first_column, 0);
        var rules = (this.topState() === 'macro' ? 'macro\'s' : this.topState());
        var pos_str = this.showPosition(l1, l2);

        if (pos_str && pos_str[0] !== '\n') {
          pos_str = '\n\n       Offending input:\n' + indent(pos_str, 4);
        }

        yy_.yyerror(
          'unsupported lexer input: ' + dquote(yy_.yytext) + ' while lexing ' + rules + '\n       (i.e. jison lex regexes).\n\n       NOTE: When you want the input ' + dquote(yy_.yytext) + ' to be interpreted as a literal part\n       of a lex rule regex, you MUST enclose it in double or single quotes,\n       e.g. as shown in this error message just before. If not, then know\n       that this is not accepted as a regex operator here in\n       jison-lex ' + rules + '.' + pos_str
        );

        break;
      case 87:
        var l0 = Math.max(0, yy_.yylloc.last_column - yy_.yylloc.first_column);
        var l2 = 39;
        var l1 = Math.min(79 - 4 - l0 - l2, yy_.yylloc.first_column, 0);
        var pos_str = this.showPosition(l1, l2);

        if (pos_str && pos_str[0] !== '\n') {
          pos_str = '\n\n       Offending input:\n' + indent(pos_str, 4);
        }

        yy_.yyerror(
          'unsupported lexer input: ' + dquote(yy_.yytext) + ' while lexing in ' + dquote(this.topState()) + ' state.' + pos_str
        );

        break;
      default:
        return this.simpleCaseActionClusters[yyrulenumber];
      }
    },

    simpleCaseActionClusters: {
      0: 26,
      1: 26,
      2: 26,
      3: 26,
      4: 26,
      5: 26,
      6: 26,
      9: 20,
      11: 8,
      12: 7,
      18: 20,
      19: 18,
      24: 40,
      28: 25,
      46: 9,
      47: 27,
      48: 27,
      49: 27,
      50: 10,
      51: 11,
      52: 12,
      53: 7,
      54: 13,
      55: 16,
      56: 8,
      57: 17,
      61: 33,
      63: 17,
      64: 15,
      71: 34,
      72: 29,
      73: 29,
      74: 3,
      75: 4,
      76: 32,
      77: 32,
      79: 43,
      88: 1
    },

    rules: [
      /^(?:\/\*(.|\n|\r)*?\*\/)/,
      /^(?:\/\/.*)/,
      /^(?:\/[^ \/]*?['"{}][^ ]*?\/)/,
      /^(?:"(\\\\|\\"|[^"])*")/,
      /^(?:'(\\\\|\\'|[^'])*')/,
      /^(?:[\/"'][^{}\/"']+)/,
      /^(?:[^{}\/"']+)/,
      /^(?:\{)/,
      /^(?:\})/,
      new XRegExp(
        '^(?:([\\p{Alphabetic}_](?:[\\p{Alphabetic}\\p{Number}\\-_]*(?:[\\p{Alphabetic}\\p{Number}_]))?))',
        ''
      ),
      /^(?:>)/,
      /^(?:,)/,
      /^(?:\*)/,
      /^(?:(\r\n|\n|\r)+)/,
      /^(?:([^\S\n\r])+(\r\n|\n|\r)+)/,
      /^(?:([^\S\n\r])+)/,
      /^(?:%%)/,
      /^(?:([^\s!"$%'-,.\/:-?\[-\^{-}])+)/,
      new XRegExp(
        '^(?:([\\p{Alphabetic}_](?:[\\p{Alphabetic}\\p{Number}\\-_]*(?:[\\p{Alphabetic}\\p{Number}_]))?))',
        ''
      ),
      /^(?:=)/,
      /^(?:"((?:\\"|\\[^"]|[^"\\])*)")/,
      /^(?:'((?:\\'|\\[^']|[^'\\])*)')/,
      /^(?:\/\/[^\r\n]*)/,
      /^(?:\/\*(.|\n|\r)*?\*\/)/,
      /^(?:\S+)/,
      /^(?:(\r\n|\n|\r)([^\S\n\r])+(?=\S))/,
      /^(?:(\r\n|\n|\r))/,
      /^(?:([^\S\n\r])+)/,
      new XRegExp('^(?:([\\p{Alphabetic}_](?:[\\p{Alphabetic}\\p{Number}_])*))', ''),
      /^(?:(\r\n|\n|\r)+)/,
      /^(?:([^\S\n\r])+)/,
      /^(?:([^\S\n\r])*(\r\n|\n|\r)+)/,
      /^(?:([^\S\n\r])*(\r\n|\n|\r)+)/,
      /^(?:\{)/,
      /^(?:%\{((?:.|(\r\n|\n|\r))*?)%\})/,
      /^(?:%\{((?:.|(\r\n|\n|\r))*?)%\})/,
      /^(?:%include\b)/,
      /^(?:.*)/,
      new XRegExp('^(?:([\\p{Alphabetic}_](?:[\\p{Alphabetic}\\p{Number}_])*))', ''),
      /^(?:(\r\n|\n|\r)+)/,
      /^(?:([^\s!"$%'-,.\/:-?\[-\^{-}])+)/,
      /^(?:(\r\n|\n|\r)+)/,
      /^(?:\s+)/,
      /^(?:"((?:\\"|\\[^"]|[^"\\])*)")/,
      /^(?:'((?:\\'|\\[^']|[^'\\])*)')/,
      /^(?:\[)/,
      /^(?:\|)/,
      /^(?:\(\?:)/,
      /^(?:\(\?=)/,
      /^(?:\(\?!)/,
      /^(?:\()/,
      /^(?:\))/,
      /^(?:\+)/,
      /^(?:\*)/,
      /^(?:\?)/,
      /^(?:\^)/,
      /^(?:,)/,
      /^(?:<<EOF>>)/,
      /^(?:<)/,
      /^(?:\/!)/,
      /^(?:\/)/,
      /^(?:\\([0-7]{1,3}|[$(-+.\/?BDSW\[-\^bdfnr-tvw{-}]|c[A-Z]|x[\dA-F]{2}|u[\dA-Fa-f]{4}))/,
      /^(?:\\.)/,
      /^(?:\$)/,
      /^(?:\.)/,
      /^(?:%options\b)/,
      /^(?:%s\b)/,
      /^(?:%x\b)/,
      /^(?:%include\b)/,
      new XRegExp(
        '^(?:%([\\p{Alphabetic}_](?:[\\p{Alphabetic}\\p{Number}\\-_]*(?:[\\p{Alphabetic}\\p{Number}_]))?)([^\\n\\r]*))',
        ''
      ),
      /^(?:%%)/,
      /^(?:\{\d+(,\s?\d+|,)?\})/,
      new XRegExp('^(?:\\{([\\p{Alphabetic}_](?:[\\p{Alphabetic}\\p{Number}_])*)\\})', ''),
      new XRegExp('^(?:\\{([\\p{Alphabetic}_](?:[\\p{Alphabetic}\\p{Number}_])*)\\})', ''),
      /^(?:\{)/,
      /^(?:\})/,
      /^(?:(?:\\\\|\\\]|[^\]{])+)/,
      /^(?:\{)/,
      /^(?:\])/,
      /^(?:[^\r\n]*(\r|\n)+)/,
      /^(?:[^\r\n]+)/,
      /^(?:(\r\n|\n|\r))/,
      /^(?:"((?:\\"|\\[^"]|[^"\\])*)")/,
      /^(?:'((?:\\'|\\[^']|[^'\\])*)')/,
      /^(?:([^\S\n\r])+)/,
      /^(?:\S+)/,
      /^(?:.)/,
      /^(?:.)/,
      /^(?:$)/
    ],

    conditions: {
      'code': {
        rules: [68, 69, 79, 80, 87, 88],
        inclusive: false
      },

      'start_condition': {
        rules: [22, 23, 28, 29, 30, 87, 88],
        inclusive: false
      },

      'options': {
        rules: [18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 73, 87, 88],
        inclusive: false
      },

      'conditions': {
        rules: [9, 10, 11, 12, 87, 88],
        inclusive: false
      },

      'action': {
        rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 87, 88],
        inclusive: false
      },

      'path': {
        rules: [22, 23, 81, 82, 83, 84, 85, 87, 88],
        inclusive: false
      },

      'set': {
        rules: [73, 76, 77, 78, 87, 88],
        inclusive: false
      },

      'indented': {
        rules: [
          32,
          33,
          34,
          35,
          36,
          37,
          41,
          42,
          43,
          44,
          45,
          46,
          47,
          48,
          49,
          50,
          51,
          52,
          53,
          54,
          55,
          56,
          57,
          58,
          59,
          60,
          61,
          62,
          63,
          64,
          65,
          66,
          67,
          70,
          71,
          72,
          74,
          75,
          87,
          88
        ],

        inclusive: true
      },

      'trail': {
        rules: [
          22,
          23,
          31,
          35,
          41,
          42,
          43,
          44,
          45,
          46,
          47,
          48,
          49,
          50,
          51,
          52,
          53,
          54,
          55,
          56,
          57,
          58,
          59,
          60,
          61,
          62,
          63,
          64,
          65,
          66,
          67,
          68,
          69,
          70,
          71,
          72,
          74,
          75,
          87,
          88
        ],

        inclusive: true
      },

      'rules': {
        rules: [
          13,
          14,
          15,
          16,
          17,
          22,
          23,
          35,
          41,
          42,
          43,
          44,
          45,
          46,
          47,
          48,
          49,
          50,
          51,
          52,
          53,
          54,
          55,
          56,
          57,
          58,
          59,
          60,
          61,
          62,
          63,
          64,
          65,
          66,
          67,
          69,
          70,
          71,
          72,
          74,
          75,
          86,
          87,
          88
        ],

        inclusive: true
      },

      'macro': {
        rules: [
          22,
          23,
          35,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          46,
          47,
          48,
          49,
          50,
          51,
          52,
          53,
          54,
          55,
          56,
          57,
          58,
          59,
          60,
          61,
          62,
          63,
          64,
          65,
          66,
          67,
          70,
          71,
          72,
          74,
          75,
          86,
          87,
          88
        ],

        inclusive: true
      },

      'INITIAL': {
        rules: [
          22,
          23,
          35,
          38,
          41,
          42,
          43,
          44,
          45,
          46,
          47,
          48,
          49,
          50,
          51,
          52,
          53,
          54,
          55,
          56,
          57,
          58,
          59,
          60,
          61,
          62,
          63,
          64,
          65,
          66,
          67,
          68,
          69,
          70,
          71,
          72,
          74,
          75,
          87,
          88
        ],

        inclusive: true
      }
    }
  };

  function indent(s, i) {
    var a = s.split('\n');
    var pf = new Array(i + 1).join(' ');
    return pf + a.join('\n' + pf);
  }

  function dquote(s) {
    var sq = s.indexOf('\'') >= 0;
    var dq = s.indexOf('"') >= 0;

    if (sq && dq) {
      s = s.replace(/"/g, '\\"');
      dq = false;
    }

    if (dq) {
      s = '\'' + s + '\'';
    } else {
      s = '"' + s + '"';
    }

    return s;
  }

  lexer.warn = function l_warn() {
    if (this.yy && this.yy.parser && typeof this.yy.parser.warn === 'function') {
      return this.yy.parser.warn.apply(this, arguments);
    } else {
      console.warn.apply(console, arguments);
    }
  };

  lexer.log = function l_log() {
    if (this.yy && this.yy.parser && typeof this.yy.parser.log === 'function') {
      return this.yy.parser.log.apply(this, arguments);
    } else {
      console.log.apply(console, arguments);
    }
  };

  return lexer;
}();
parser.lexer = lexer;

function Parser() {
  this.yy = {};
}
Parser.prototype = parser;
parser.Parser = Parser;

return new Parser();
})();




if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
  exports.parser = lexParser;
  exports.Parser = lexParser.Parser;
  exports.parse = function () {
    return lexParser.parse.apply(lexParser, arguments);
  };
  
}
