//
// Stage 2(C) parser: 'The Back End = The Pretty Printer'
//
// TODO!
//
// This one represents the classic textbook 'parser/tokenizer' backend: 
// using a 'tree walker' to generate 'object code output': in this case 
// the 'backend' is tasked to 'pretty print' the given formula
// so that the human user can be fed back her input, including possible
// color coding, error markup, tagging and what-not.
//
// This is yet another back-end to un alongside the others: 
// compile_calc_exec and compile_calc_codegen.
//
// The AST is stored in an array and since the AST acts as the INTERFACE
// between front-end and backend of the compiler/engine, its precise format
// is known to both 'parsers': the compile_calc_parse front-end and this
// back-end, plus additional back-ends which feed off the same AST for
// different purposes.
//
// This 'Pretty Printer' is designed to be FAST, hence the AST stream has been
// constructed the way it is, using a Polish Notation simile: this takes
// the fewest AST nodes and the fewest number of grammar rules to express
// the entire formula calculation power.
//
// We also assume the AST is always valid (errors can be encoded in there, but
// we will exit HARD when your front-end screwed up the AST 'internal structure'
// in any way!), the result of which is that we now have enabled jison to
// recognize the absence of all and any error checking and reporting facilities,
// which our JISON takes as an opportunity to create a severely stripped down,
// FAST grammar parser, hence a very fast 'tree walker'.
//
// Of course, the usual process is to write such a 'tree walker' by hand,
// but I want to showcase the concept here and there's something to say for
// readability as now AST format and actions performed on the atoms is
// nicely separated! :-)
//
// ---
//
// A crucial detail is the use of the `%import` jison feature which allows
// us to import the symbol table generated by jison as part of the front-end
// parser engine: that way we have a guaranteed good set of token #IDs which we
// can use at both ends of the AST stream interface: this allows us to use
// the other JISON feature which is `#<name>` in the action blocks everywhere:
// this will be expanded into the numeric ID of the given token by jison,
// saving us from having to generate and maintain a separate table of IDs
// for our AST objects!
//
// ---
//
// This example also uses the new JISON `%include` feature which allows us
// to include any given source file *verbatim* in our generated jison output.
// Thus we will produce a complete, working, app in a single file here.
// (See near bottom of this jison file.)



%import symbols  "./output/compiled_calc/compiled_calc_parse.js"







%token      NUM             // Simple double precision number
%token      VAR FUNCTION    // Variable and Function
%token      CONSTANT        // Predefined Constant Value, e.g. PI or E
%token      ERROR           // Mark error in statement
%token      COMMENT         // A line (or multiple lines) of comment

%token      END             // token to mark the end of a function argument list in the output token stream
%token      FUNCTION_0      // optimization: function without any input parameters
%token      FUNCTION_1      // optimization: function with one input parameter
%token      FUNCTION_2      // optimization: function with two input parameters
%token      FUNCTION_3      // optimization: function with three input parameters

%nonassoc   IF_ELSE         // IF ... THEN ... ELSE ...
%nonassoc   IF              // IF ... THEN ... (ELSE nil) -- the 'dangling else' issue has already been resolved by the *parser* hence this AST input stream doesn't suffer from that issue any more!


// %right      '='
%nonassoc   ASSIGN

%nonassoc   XOR
%nonassoc   OR
%nonassoc   AND

%nonassoc   EQ NEQ GEQ LEQ GT LT

// %left       '^'
// %left       '|'
// %left       '&'
%nonassoc   BITWISE_XOR
%nonassoc   BITWISE_OR
%nonassoc   BITWISE_AND

// %left       '-' '+'
// %left       '*' '/' '%'
// %right      POWER
// %right      '~'
// %right      '!' NOT
%nonassoc   ADD SUBTRACT
%nonassoc   MULTIPLY DIVIDE MODULO
%nonassoc   POWER
%nonassoc   BITWISE_NOT
%nonassoc   NOT
%nonassoc   FACTORIAL
%nonassoc   UMINUS     /* Negation--unary minus */
%nonassoc   UPLUS      /* unary plus */
%nonassoc   PERCENT    /* unary percentage */




/* Grammar follows */

%start input



//%options on-demand-lookahead    // camelCased: option.onDemandLookahead
%options no-default-action      // JISON shouldn't bother injecting the default `$$ = $1` action anywhere!
%options no-try-catch           // we assume this parser won't ever crash and we want the fastest Animal possible! So get rid of the try/catch/finally in the kernel!

%parse-param globalSpace        // extra function parameter for the generated parse() API; we use this one to pass in a reference to our workspace for the functions to play with.



%%


input:
  Îµ                             /* empty */
                                {
                                  $$ = [];
                                }
| input line EOL
                                {
                                  $input.push($line);
                                  $$ = $input;
                                }
| input COMMENT EOL
                                {
                                  var comment = $COMMENT.split('\n');
                                  comment.forEach(function (cmtline) {
                                    $input.push('# ', cmtline);
                                  });
                                  $$ = $input;
                                }
;

line:
  exp
                                {
                                  console.log('expression result value: ', $exp);
                                  $$ = $exp;
                                }
| ERROR
                                {
                                  console.log('expression result value: ERROR - erroneous input line');
                                  $$ = 'ERROR: ', $ERROR;
                                }
;


exp:
  NUM
                                { 
                                  $$ = $(#NUM, $NUM); 
                                }
| CONSTANT
                                { 
                                  $$ = $(#CONSTANT, yy.constants[$CONSTANT].name); 
                                }
| VAR
                                { 
                                  $$ = $(#VAR, yy.variables[$VAR].name); 
                                }
| ASSIGN exp
                                {
                                  /*
                                     Note: #assign is always to a simple variable, hence we don't need the `#VAR`
                                     token here: it is implicit as there's nothing else we can do.

                                     Technically, this is an AST optimization, but it's such a fundamental one
                                     we do it here instead of later.

                                     NOTE: #assign implies the presence of a VAR as lhs (left hand side) so it
                                     would only be cluttering the AST stream to have a #VAR# token in there:
                                     it is *implicit* to #assign!
                                   */
                                  $$ = $(#ASSIGN, yy.variables[$ASSIGN].name, '=', __($exp, 0, #ASSIGN));
                                  //$$ = yy.variables[$ASSIGN].name = $exp;
                                }
| FUNCTION_0
                                { 
                                  $$ = $(#FUNCTION_0#, yy.functions[$FUNCTION_0].name);
                                }
| FUNCTION arglist END
                                {
                                  //$$ = $(#FUNCTION#, yy.functions[$FUNCTION_0].name, arglist);
                                  $arglist.unshift(#FUNCTION#, yy.functions[$FUNCTION_0].name);
                                  $$ = $.apply(this, arglist);
                                }
| FUNCTION_1 exp
                                {
                                  $$ = $(#FUNCTION_1#, yy.functions[$FUNCTION_1].name, $exp);
                                }
| FUNCTION_2 exp exp
                                {
                                  $$ = $(#FUNCTION_2#, yy.functions[$FUNCTION_2].name, $exp1, $exp2);
                                }
| FUNCTION_3 exp exp exp
                                {
                                  $$ = $(#FUNCTION_3#, yy.functions[$FUNCTION_3].name, $exp1, $exp2, $exp3);
                                }

| EQ exp exp
                                { $$ = $(#EQ, $exp1, $exp2); }
| NEQ exp exp
                                { $$ = $(#NEQ, $exp1, $exp2); }
| LEQ exp exp
                                { $$ = $(#LEQ, $exp1, $exp2); }
| GEQ exp exp
                                { $$ = $(#GEQ, $exp1, $exp2); }
| LT exp exp
                                { $$ = $(#LT, $exp1, $exp2); }
| GT exp exp
                                { $$ = $(#GT, $exp1, $exp2); }
| OR exp exp
                                { $$ = $(#OR, $exp1, $exp2); }
| XOR exp exp
                                { $$ = $(#XOR, $exp1, $exp2); }
| AND exp exp
                                { $$ = $(#AND, $exp1, $exp2); }

| BITWISE_OR exp exp
                                { $$ = $(#BITWISE_OR, $exp1, $exp2); }
| BITWISE_XOR exp exp
                                { $$ = $(#BITWISE_XOR, $exp1, $exp2); }
| BITWISE_AND exp exp
                                { $$ = $(#BITWISE_AND, $exp1, $exp2); }

| ADD exp exp
                                { $$ = $(#ADD, $exp1, $exp2); }
| SUBTRACT exp exp
                                { $$ = $(#SUBTRACT, $exp1, $exp2); }
| MULTIPLY exp exp
                                { $$ = $(#MULTIPLY, $exp1, $exp2); }
| DIVIDE exp exp
                                { $$ = $(#DIVIDE, $exp1, $exp2); }
| MODULO exp exp
                                { $$ = $(#MODULO, $exp1, $exp2); }
| UMINUS exp
                                { $$ = $(#UMINUS, $exp1); }
| UPLUS exp
                                { $$ = $(#UPLUS, $exp1); }
| POWER exp exp
                                { $$ = $(#POWER, $exp1, $exp2); }
| PERCENT exp
                                { $$ = $(#PERCENT, $exp1); }
| FACTORIAL exp
                                { $$ = $(#FACTORIAL, $exp1); }

| BITWISE_NOT exp
                                { $$ = $(#BITWISE_NOT, $exp1); }
| NOT exp
                                { $$ = $(#NOT, $exp1); }


| IF_ELSE exp exp exp
                                { $$ = $(#IF_ELSE, $exp1, $exp2, $exp3); }
| IF exp exp
                                { $$ = $(#IF, $exp1, $exp2); }
;

arglist:
  exp
                                { $$ = [$exp]; }
| arglist exp
                                {
                                  $$ = $arglist;
                                  $$.push($exp);
                                }
;





/* End of grammar */


%%

/* @const */ var print_def = {
  
};

function $(op /* ,... */ ) {
  // first check how many args we got:
  var args = arguments.slice(1);
  var cnt = args.length;

  // - if any arg contains content which carries *lower* precedences, it must be braced.
  // - if the left/right argument contains content with the *same* precedence and is not supposed to, given this op's *associativity*, then it must be braced.
  var brace_me = new Array(cnt);
  var my_prec = precedence_order[op] || 0;    // precedence is higher when number is LOWER!
  var my_assoc = associativity[op] || 0;

  var s = display[op];

  for (var i = 0; i < cnt; i++) {
    // is argument an 'augmented item'?
    var a = args[i];
    if (!a.augmented) continue;
    // check precedence:
    brace_me[i] = (a.precedence > my_prec);
    // check associativity?
    if (a.precedence >= my_prec && my_assoc != i) {
      brace_me[i] = true; 
    }

    // replace arg [0] via regex `/1/`, etc.:
    var re = argument_regex[i];
    if (!re) {
      re = argument_regex[i] = new RegExp('' + (i + 1));
    }
    s = s
    .replace(re, function () {
      var s = a.display;
      if (brace_me[i]) {
        s = '(' + s + ')';
      }
      // #FUNCTION# receives special treatment: arg1..argN are function arguments and must be separated by `,`,
      // which cannot be easily done by a simple regex replacement template alone:
      if (op === FUNCTION && i >= 1 && i < cnt - 1) {
        s += ', ';
      }
      return s;
    });
  }

  return {
    display: s,
    precedence: my_prec,
  };  
}

